<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title> Python面向对象编程 - wtlinux-职业生涯记录</title>
  <meta name="description" content="wtlinux-职业生涯记录" />
  <meta property="og:title" content="Python面向对象编程" />
  <meta name="twitter:title" content="Python面向对象编程" />
  <meta name="description" content="对文章的简要描述 SEO used for description">
  <meta property="og:description" content="对文章的简要描述 SEO used for description">
  <meta name="twitter:description" content="对文章的简要描述 SEO used for description">
  <meta name="author" content="wangtian"/>
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://www.eee.wiki/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="wtlinux" />

  <meta name="generator" content="Hugo 0.41" />
  <link rel="canonical" href="https://www.eee.wiki/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" />
  <link rel="alternate" href="https://www.eee.wiki/index.xml" type="application/rss+xml" title="wtlinux">
  <script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/jquery-1.12.4.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  
  
  <link rel="stylesheet" href="https://www.eee.wiki/css/main.css" />
  <link rel="stylesheet" href="https://www.eee.wiki/css/search.css" />
  
  

<meta name="baidu-site-verification" content="g8IYR9SNLF" />
<script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
    })();
</script>

<link rel="stylesheet" href="https://www.eee.wiki/css/prism.css" />




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css" integrity="sha256-sCl5PUOGMLfFYctzDW3MtRib0ctyUvI9Qsmq2wXOeBY=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css" integrity="sha256-BFeI1V+Vh1Rk37wswuOYn5lsTcaU96hGaI7OUVCLjPc=" crossorigin="anonymous" />



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://www.eee.wiki/">wtlinux</a>
    </div>
    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Home" href="/home">Home</a>
              
              
            </li>
          
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">Categories</a>
              <div class="navlinks-children">
                
                
                  <a href="https://www.eee.wiki/tags/ops">ops</a>
                
                
                  <a href="https://www.eee.wiki/tags/dev">dev</a>
                
                
                  <a href="https://www.eee.wiki/tags/error">error</a>
                
                
                  <a href="https://www.eee.wiki/tags">Tags</a>
                
              </div>
            </li>
          
        
          
            <li>
              <a title="About" href="/about">About</a>
              
              
            </li>
          
        
          
            <li>
              <a title="talk" href="/tags/talk">talk</a>
              
              
            </li>
          
        

        

        
        
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
      </div>
    </div>

  </div>
</nav>






    
  
  
  




  
    <div id="header-big-imgs" data-num-img=1 data-img-src-1="https://ws2.sinaimg.cn/large/006tNc79gy1ftcuzmw47tj30hi08rgs2.jpg" data-img-desc-1="Shanghai China| 2018-07-19T15:07:07&#43;08:00"></div>
  

  <header class="header-section has-img">
    
      <div class="intro-header big-img">
        
        
        <div class="container">
          <div class="row">
              <div class="col-lg-12 col-md-12 col-md-offset-0">
                
                <div class="post-heading">
                
                  
                     <h1>Python面向对象编程</h1>
                     
                     
                  
                  
                  
                    
                      <hr class="small">
                      <span class="post-subheading">Python面向对象编程</span>
                    
                  
                  
                    <span class="post-meta">
  
  Posted on July 19, 2018
  
  
</span>


                  
                
              </div>
            </div>
          </div>
        </div>
        <span class="img-desc" style="display: inline;"></span>
      </div>
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-12 col-md-12 col-md-offset-0">
            <div class="posts-heading">
                <h1 align="center">Python面向对象编程</h1>
                
                  
                    <h2 align="center" class="posts-subheading">Python面向对象编程</h2>
                  
                
                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main" itemscope itemtype="http://schema.org/Article">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            
            
              
            <article role="main" class="blog-post" itemprop="articleBody" id="content">
                
   
  <aside class="toc">
    <nav id="TableOfContents">
<ul>
<li><a href="#面向对象简介">面向对象简介</a>
<ul>
<li><a href="#面向对象的几个核心特点">面向对象的几个核心特点：</a></li>
</ul></li>
<li><a href="#类和对象">类和对象</a>
<ul>
<li><a href="#类的定义">类的定义</a></li>
</ul></li>
<li><a href="#经典类与新式类">经典类与新式类</a></li>
<li><a href="#面向对象三大特性-封装-继承-多态">面向对象三大特性：封装、继承、多态</a>
<ul>
<li><a href="#封装">封装</a></li>
<li><a href="#继承">继承</a></li>
<li><a href="#多态">多态</a></li>
<li><a href="#总结">总结</a></li>
</ul></li>
<li><a href="#类的字段-方法-属性">类的字段、方法、属性</a>
<ul>
<li><a href="#字段">字段</a></li>
<li><a href="#方法">方法</a></li>
<li><a href="#属性">属性</a></li>
<li><a href="#属性的基本使用">属性的基本使用</a></li>
<li><a href="#属性的装饰器方式">属性的装饰器方式</a></li>
<li><a href="#属性的静态字段方式">属性的静态字段方式</a></li>
</ul></li>
<li><a href="#类的特殊成员">类的特殊成员</a></li>
<li><a href="#类成员修饰符">类成员修饰符</a></li>
<li><a href="#面向对象编程的本质">面向对象编程的本质</a>
<ul>
<li><a href="#面向对象设计利器">面向对象设计利器</a></li>
<li><a href="#领域建模三字经">领域建模三字经</a></li>
<li><a href="#找名词">找名词</a></li>
<li><a href="#加属性">加属性</a></li>
<li><a href="#连关系">连关系</a></li>
</ul></li>
</ul>
</nav>
  </aside>
   

                

<h1 id="面向对象简介">面向对象简介</h1>

<p>将抽象事物实例化，我们写的代码原则：</p>

<p>1、不写重复的代码</p>

<p>2、代码会经常修改、变更</p>

<p>面向对象编程（Object Oriented Programming，简称OOP），是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数（我们称之为方法）。</p>

<p>我们之前讲的大部分都是面向过程编程，也就是根据业务逻辑从上到下写垒代码，为了简化操作或者避免重复的代码将某功能代码封装到函数中，日后便无需重复编写，仅调用函数即可。</p>

<p>而面向对象思想是把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>

<p>其实在Python中面向对象无处不在，我们之前讲的所有的数据类型都是所对应的数据对象。每种数据类型都有自己的方法。从这章开始我们更多的是要自己创建各种数据类型，也就是真正开始和类以及对象打交道了。</p>

<h2 id="面向对象的几个核心特点">面向对象的几个核心特点：</h2>

<p><strong>Class类</strong></p>

<p>一个类即是对一类拥有相同属性的对象的抽象、蓝图、原型。在类中定义了这些对象的都具备的属性（variables(data)）、共同的方法</p>

<p><strong>Object 对象</strong></p>

<p>一个对象即是一个类的实例化后实例，一个类必须经过实例化后方可在程序中调用，一个类可以实例化多个对象，每个对象亦可以有不同的属性，就像人类是指所有人，每个人是指具体的对象，人与人之前有共性，亦有不同</p>

<p><strong>Encapsulation 封装</strong></p>

<p>在类中对数据的赋值、内部调用对外部用户是透明的，这使类变成了一个胶囊或容器，里面包含着类的数据和方法</p>

<p><strong>Inheritance 继承</strong></p>

<p>一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承</p>

<p><strong>Polymorphism 多态</strong></p>

<p>多态是面向对象的重要特性,简单点说:“一个接口，多种实现”，指一个基类中派生出了不同的子类，且每个子类在继承了同样的方法名的同时又对父类的方法做了不同的实现，这就是同一种事物表现出的多种形态。</p>

<p>编程其实就是一个将具体世界进行抽象化的过程，多态就是抽象化的一种体现，把一系列具体事物的共同点抽象出来, 再通过这个抽象的事物, 与不同的具体事物进行对话。</p>

<p>对不同类的对象发出相同的消息将会有不同的行为。比如，你的老板让所有员工在九点钟开始工作, 他只要在九点钟的时候说：“开始工作”即可，而不需要对销售人员说：“开始销售工作”，对技术人员说：“开始技术工作”, 因为“员工”是一个抽象的事物, 只要是员工就可以开始工作，他知道这一点就行了。至于每个员工，当然会各司其职，做各自的工作。</p>

<p>多态允许将子类的对象当作父类的对象使用，某父类型的引用指向其子类型的对象,调用的方法是该子类型的方法。这里引用和调用方法的代码编译前就已经决定了,而引用所指向的对象可以在运行期间动态绑定。</p>

<p>针对上述核心特点，下文将会进一步详解。</p>

<p>我们先举个例子对来面向对象有个概念，以及它与面向过程的区别。</p>

<p>假如我们描述一包烟，每包烟都有自己的名字，价格，产地，在面向对象的过程中，我们为了方便取出某一属性，习惯用字典来描述一包烟的所有属性。</p>

<pre><code>
smoke = {&quot;name&quot;:&quot;peony&quot;,&quot;price&quot;:&quot;13&quot;,&quot;place&quot;:“shanghai”}

</code></pre>

<p>如果我们需要取出它的某一属性比如它的产地，我们可以通过smoke[&laquo;place&raquo;]方式取出来，如果函数来操作这包烟的话，可以把这个字典作为参数传到函数中，例如：</p>

<pre><code>
#!/usr/bin/env python3

# -*- conding: utf-8 -*-

smoke = {&quot;name&quot;:&quot;peony&quot;,&quot;price&quot;:&quot;13&quot;,&quot;place&quot;:&quot;shanghai&quot;}


def print_info(smoke):

    print('name: %s\nprice: %s\nplace: %s' %(smoke['name'],smoke['price'],smoke['place']))


print_info(smoke)


#output

name: peony

price: 13

place: shanghai

</code></pre>

<p>我们再来看一下面向对象</p>

<pre><code>
#!/usr/bin/env python3

# -*- conding: utf-8 -*-

class Somke(object):

    def __init__(self, name, price, place):

        self.name = name

        self.price = price

        self.place = place


    def print_info(self):

        print('name: %s\nprice: %s\nplace: %s' %(self.name,self.price,self.place))


somke = Somke('peony','13','shanghai')


somke.print_info()

我们通过`class`创建了一个名为`Smoke`类，然后通过Somke('peony','13','shanghai')调用这个类的`__init__`方法,生成了一个`Smoke`类的实例`smoke`。这时候我们要打印smoke信息，我们就可以通过`somke.print_info()`方式调用`print_info`方法。

#output

name: peony

price: 13

place: shanghai

</code></pre>

<p>从上面的代码中已经看到了，面向对象和面向过程的区别，但是看起来面向对象的代码更加复杂一点，为什么我们还要用面向对象呢？这就是将抽象的东西进行实例化的一种体现，peony牡丹就是smoke烟的一个实例。</p>

<h1 id="类和对象">类和对象</h1>

<h2 id="类的定义">类的定义</h2>

<pre><code>
class classname(object):    #定义一个类，class定义类的语法，classname是类名，（object）是新式类的写法

    def funcname(parameter_list):    #定义一个函数，def定义函数的语法，funcname是函数名，parameter_list是函数的参数

        pass

</code></pre>

<h1 id="经典类与新式类">经典类与新式类</h1>

<h1 id="面向对象三大特性-封装-继承-多态">面向对象三大特性：封装、继承、多态</h1>

<h2 id="封装">封装</h2>

<p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。</p>

<p>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>

<p>所以，在使用面向对象的封装特性时，需要：</p>

<p><font color=bliue>将内容封装到某处</font></p>

<p><font color=bliue>从某处调用被封装的内容</font></p>

<p>综上所述，对于面向对象的封装来说，其实就是使用构造方法将内容封装到 对象中，然后通过对象直接或者self间接获取被封装的内容。</p>

<pre><code>
#!/usr/bin/env python3

# -*- coding: utf-8 -*-

class DNF(object):

    def __init__(self,name,age,gender):    #初始化函数，在生成一个角色时要初始化的一些属性就填写在这里

        self.name = name

        self.age = age

        self.gender = gender

    def print_show(self):

        print(self.name,self.age,self.gender,'上山去砍柴')

        print(self.name,self.age,self.gender,'开车去东北')

        print(self.name,self.age,self.gender,'最爱大保健')


xiaoming = DNF('小明','10','男')

laoli = DNF('老李','100','男')

laozhang = DNF('老张','25','男')


xiaoming.print_show()

laoli.print_show()

laozhang.print_show()

</code></pre>

<p>封装小结：对于面向对象只需要在创建对象时，将所有需要的参数封装到当前对象中，之后再次使用时，通过self间接去当前对象中取值即可。</p>

<h2 id="继承">继承</h2>

<p>继承，面向对象中的继承和现实生活中的继承相同，即：子可以继承父的内容。</p>

<p>面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p>

<p>通过继承创建的新类称为“子类”或“派生类”。</p>

<ul>
<li><p>被继承的类称为“基类”、“父类”或“超类”。</p></li>

<li><p>继承的过程，就是从一般到特殊的过程。</p></li>
</ul>

<p>要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。</p>

<p>在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。</p>

<p>继承概念的实现方式主要有2类：实现继承、接口继承。</p>

<ul>
<li><p>实现继承是指使用基类的属性和方法而无需额外编码的能力；</p></li>

<li><p>接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力(子类重构父类方法)；</p>

<p>在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。</p></li>
</ul>

<p>抽象类仅定义将由子类创建的一般属性和方法。</p>

<p>OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。</p>

<p>继承示例：</p>

<pre><code>
#!/usr/bin/env python3

# -*- coding: utf-8 -*-

class Car(object):

    def wheel(self):

        print(&quot;%s '车轮‘&quot; % self.name)

    def door(self):

        print(&quot;%s '车门'&quot; % self.name)

    def window(self):

        print(&quot;%s '车窗'&quot; % self.name)


class Benz(Car):

    def __init__(self,name):

        self.name = name

        self.breed = &quot;奔驰&quot;

    def cry(self):

        print(&quot;滴滴滴&quot;)


class BMW(Car):

    def __init__(self,name):

        self.name = name

        self.breed = &quot;宝马&quot;

    def cry(self):

        print(&quot;叭叭叭&quot;)


benz1 = Benz('伟伟')

benz1.window()

benz1.wheel()

benz1.door()

benz1.cry()


benz2 = Benz('广慧')

benz2.window()

benz2.wheel()

benz2.door()

benz2.cry()


bmw1 = BMW('忠海')

bmw1.window()

bmw1.wheel()

bmw1.door()

bmw1.cry()

</code></pre>

<p>继承小结：</p>

<p>对于面向对象的继承来说，其实就是将多个类共有的方法提取到父类中，<code>子类</code>仅需继承<code>父类</code>而不必一一实现每个方法。</p>

<p><font color=red>注：</font>除了子类和父类的称谓，你可能看到过<code>派生类</code> 和<code>基类</code> ，他们与子类和父类只是叫法不同而已。</p>

<h2 id="多态">多态</h2>

<p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。</p>

<p>那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。</p>

<h2 id="总结">总结</h2>

<ul>
<li>面向对象是一种编程方式，此编程方式的实现是基于对 类 和 对象 的使用</li>
<li>类 是一个模板，模板中包装了多个“函数”供使用</li>
<li>对象，根据模板创建的实例（即：对象），实例用于调用被包装在类中的函数</li>
<li>面向对象三大特性：封装、继承和多态</li>
</ul>

<h1 id="类的字段-方法-属性">类的字段、方法、属性</h1>

<p>类的字段、方法和属性是类的三大成员</p>

<p><font color=green>注：</font>所有成员中，只有普通字段的内容保存对象中，即：根据此类创建了多少对象，在内存中就有多少个普通字段。而其他的成员，则都是保存在类中，即：无论对象的多少，在内存中只创建一份。</p>

<h2 id="字段">字段</h2>

<p>字段包括：普通字段和静态字段，他们在定义和使用中有所区别，而最本质的区别是内存中保存的位置不同。</p>

<ul>
<li><p>普通字段属于<font color=red>对象</font></p></li>

<li><p>静态字段属于<font color=red>类</font></p></li>
</ul>

<p>先来撸一串代码</p>

<pre><code>
#!/usr/bin/env python3

# -*- conding: utf-8 -*-

class Bailian(object):

company = '百联' # 静态字段



def __init__(self,name):

self.name=name # 普通字段



obj = Bailian('百联大宗')

print(obj.name) #直接访问普通字段



print(Bailian.company)  #直接访问静态字段

</code></pre>

<p>由上述代码可以看出【普通字段需要通过对象来访问】【静态字段通过类来访问】，在使用上可以看出普通字段和静态字段的归属是不同的。其在内容的存储方式不同：</p>

<ul>
<li><p>静态字段在内存中只保存一份</p></li>

<li><p>普通字段在每个对象中都要保存一份</p></li>
</ul>

<p>应用场景：通过类创建对象时，如果每个对象都具有相同的字段，那么就使用静态字段。</p>

<h2 id="方法">方法</h2>

<p>方法包括：普通方法、静态方法和类方法，三种方法在内存中都归属类，区别在于调用方式不同。</p>

<ul>
<li><p>普通方法：由<code>对象</code>调用；至少需要一个<code>self</code>参数；执行普通方法时，自动将调用该方法的<code>对象</code>赋值给<code>self</code>；</p></li>

<li><p>类方法：由<code>类</code>调用；至少需要一个<code>cls</code>参数；执行类方法时，自动将调用该方法的<code>类</code>赋值给<code>cls</code>；</p></li>

<li><p>静态方法：由<code>类</code>调用；无默认参数</p></li>
</ul>

<p>再来撸一段代码：</p>

<pre><code>
#!/usr/bin/env python3

# -*- conding: utf-8 -*-

class Foo(object):

def __init__(self,name):

self.name = name



def ord_func(self):     #定义一个普通方法，至少需要一个self参数

print(self.name)

@classmethod

def class_func(cls):    #定义一个类方法，至少需要一个cls参数

print('类方法')



@staticmethod

def static_func():      #定义一个静态方法，无需默认参数

print('静态方法')

#调用普通方法

f = Foo('普通方法')

f.ord_func()

#调用类方法

Foo.class_func()

#调用静态方法

Foo.static_func()

</code></pre>

<p>相同点：对于所有的方法而言，均属于类（非对象）中，所以，在内存中也只保存一份。</p>

<p>不同点：方法调用者不同、调用方法时自动传入的参数不同。</p>

<h2 id="属性">属性</h2>

<p>如果你已经了解python类中的方法，那么属性就非常简单了，因为python中的属性其实是<strong>普通方法</strong>的变种。</p>

<p>对于属性，有以下三个知识点：</p>

<ul>
<li><p>属性的基本使用</p></li>

<li><p>属性的装饰器方式</p></li>

<li><p>属性的静态字段方式</p></li>
</ul>

<h2 id="属性的基本使用">属性的基本使用</h2>

<p>再来撸一串代码：</p>

<pre><code>
#!/usr/bin/env python3

# -*- conding: utf-8 -*-



class Foo(object):          #定义

def func(self):

pass



@property

def prop(self):         #定义属性

pass

foo_obj = Foo()

foo_obj.prop              #调用属性



</code></pre>

<p>由属性的定义和调用要注意以下几点：</p>

<ul>
<li><p>定义时，在普通方法的基础上添加<code>@property</code>装饰器；</p></li>

<li><p>定义时，属性<code>仅有一个</code>self参数</p></li>

<li><p>调用时，无需<code>括号</code>    方法：foo_obj.func()    属性：foo_obj.prop</p></li>
</ul>

<p>注意：属性存在意义是：访问属性时可以制造出和访问字段完全相同的假象。</p>

<pre><code>       属性由方法变种而来，如果python中没有属性，方法完全可以代替其功能。
</code></pre>

<p>实例：对于主机列表页面，每次请求不可能把数据库中的所有内容都放在页面上，而是通过分页的功能局部显示，所以在向数据库中请求数据时就要显示指定获取从第m条到第n条的所有数据（即： limit m, n）,这个分页的功能包括：</p>

<ul>
<li><p>根据用户请求当前页面和总数据条数计算出m和n</p></li>

<li><p>根据m和n去数据库中请求数据。</p></li>
</ul>

<pre><code>
#!/usr/bin/env python3

# -*- coding: utf-8 -*-

#####定义##########

class Pager:

    def __init__(self,current_page):

        #用户当前请求的页码（第一页，第二页....）

        self.current_page = current_page

        #每页默认显示10条数据

        self.per_items = 10



    @property

    def start(self):

        val = (self.current_page - 1 ) * self.per_items

        return val



    @property

    def end(self):

        val = self.current_page * self.per_items

        return val

##调用######

p = Pager(1)

print(p.start)    #就是起始值，即m

print(p.end)     #就是结束值，即n

</code></pre>

<p>从上述可见，python的属性功能是：<font color = red>属性内部进行一系列的逻辑运算，最终将计算结果返回</font>。</p>

<h2 id="属性的装饰器方式">属性的装饰器方式</h2>

<p><strong>装饰器方式</strong>：在类的普通方法上应用@property装饰器</p>

<p>我们知道python中的类有经典类和新式类，新式类的属性比经典类的属性丰富（如果类继object，那么该类是新式类）</p>

<p>经典类，具有一种@property装饰器（如上一步实例）</p>

<pre><code>
#!/usr/bin/env python3

# -*- conding: utf-8 -*-



# ######## 定义 ########    

class Goods:



    @property

    def price(self):

        return &quot;wupeiqi&quot;

# ######## 调用 ########

obj = Goods()

result = obj.price  # 自动执行 @property 修饰的 price 方法，并获取方法的返回值

        

print(result)

</code></pre>

<p>新式类，具有三种@property装饰器</p>

<pre><code>
# ######## 定义 ########

class Goods(object):



    @property

    def price(self):

        print '@property'



    @price.setter

    def price(self, value):

        print '@price.setter'



    @price.deleter

    def price(self):

        print '@price.deleter'



# ######## 调用 ########

obj = Goods()



obj.price          # 自动执行 @property 修饰的 price 方法，并获取方法的返回值



obj.price = 123    # 自动执行 @price.setter 修饰的 price 方法，并将  123 赋值给方法的参数



del obj.price      # 自动执行 @price.deleter 修饰的 price 方法

</code></pre>

<p>注：经典类中的属性只有一种访问方式，其对应被@property修饰的方法</p>

<p>新式类中的属性有三种访问方式，并分别对应了三个被@property、@方法名.setter、@方法名.deleter修饰的方法</p>

<p>由于新式类中具有三种访问方式，我们可以根据他们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p>

<pre><code>
#!/usr/bin/env python3

# -*- conding: utf-8 -*-



class Goods(object):



    def __init__(self):

        # 原价

        self.original_price = 100

        # 折扣

        self.discount = 0.8



    @property

    def price(self):

        # 实际价格 = 原价 * 折扣

        new_price = self.original_price * self.discount

        return new_price



    @price.setter

    def price(self, value):

        self.original_price = value



    @price.deltter

    def price(self, value):

        del self.original_price



obj = Goods()

obj.price         # 获取商品价格

obj.price = 200   # 修改商品原价

del obj.price     # 删除商品原价

</code></pre>

<h2 id="属性的静态字段方式">属性的静态字段方式</h2>

<p>静态字段方式，创建值为property对象的静态字段</p>

<p>当使用静态字段的方式创建属性时，经典类和新式类无区别</p>

<pre><code>
#!/usr/bin/env python3

# -*- conding: utf-8 -*-



class Foo:



    def get_bar(self):

        return 'wupeiqi'



    BAR = property(get_bar)



obj = Foo()

reuslt = obj.BAR        # 自动调用get_bar方法，并获取方法的返回值

print reuslt

</code></pre>

<p>property的构造方法中有个四个参数</p>

<ul>
<li><p>第一个参数是方法名，调用<code>对象.属性</code>时自动触发执行方法</p></li>

<li><p>第二个参数是方法名，调用<code>对象.属性 = xxx</code>时自动触发执行方法</p></li>

<li><p>第三个参数是方法名，调用<code>del 对象.属性</code>时自动触发执行方法</p></li>

<li><p>第四个参数是字符串，调用<code>对象.属性.__doc__</code>，此参数是该属性的描述信息</p></li>
</ul>

<pre><code>
#!/usr/bin/env python3

# -*- conding: utf-8 -*-



class Foo：



    def get_bar(self):

        return 'wupeiqi'



    # *必须两个参数

    def set_bar(self, value): 

        return return 'set value' + value



    def del_bar(self):

        return 'wupeiqi'



    BAR ＝ property(get_bar, set_bar, del_bar, 'description...')



obj = Foo()



obj.BAR              # 自动调用第一个参数中定义的方法：get_bar

obj.BAR = &quot;alex&quot;     # 自动调用第二个参数中定义的方法：set_bar方法，并将“alex”当作参数传入

del Foo.BAR          # 自动调用第三个参数中定义的方法：del_bar方法

obj.BAE.__doc__      # 自动获取第四个参数中设置的值：description...

</code></pre>

<p>由于静态字段方式创建属性具有三种访问方式，我们可以根据他们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p>

<pre><code>
#!/usr/bin/env python3

# -*- conding: utf-8 -*-



class Goods(object):



    def __init__(self):

        # 原价

        self.original_price = 100

        # 折扣

        self.discount = 0.8



    def get_price(self):

        # 实际价格 = 原价 * 折扣

        new_price = self.original_price * self.discount

        return new_price



    def set_price(self, value):

        self.original_price = value



    def del_price(self, value):

        del self.original_price



    PRICE = property(get_price, set_price, del_price, '价格属性描述...')



obj = Goods()

obj.PRICE         # 获取商品价格

obj.PRICE = 200   # 修改商品原价

del obj.PRICE     # 删除商品原价

</code></pre>

<p>注意：Python WEB框架 Django 的视图中 request.POST 就是使用的静态字段的方式创建的属性</p>

<p>所以，定义属性共有两种方式，分别是【装饰器】和【静态字段】，而【装饰器】方式针对经典类和新式类又有所不同。</p>

<h1 id="类的特殊成员">类的特殊成员</h1>

<p>上文介绍了Python的类成员以及成员修饰符，从而了解到类中有字段、方法和属性三大类成员，并且成员名前如果有两个下划线，则表示该成员是私有成员，私有成员只能由类内部调用。无论人或事物往往都有不按套路出牌的情况，Python的类成员也是如此，存在着一些具有特殊含义的成员，详情如下：</p>

<ol>
<li><strong>doc</strong></li>
</ol>

<p>　　表示类的描述信息</p>

<ol>
<li><strong>module</strong> 和  <strong>class</strong></li>
</ol>

<p>　　<strong>module</strong> 表示当前操作的对象在那个模块</p>

<p>　　<strong>class</strong>    表示当前操作的对象的类是什么</p>

<ol>
<li><strong>init</strong></li>
</ol>

<p>　　构造方法，通过类创建对象时，自动触发执行。</p>

<ol>
<li><strong>del</strong></li>
</ol>

<p>　　析构方法，当对象在内存中被释放时，自动触发执行。</p>

<p>注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。</p>

<ol>
<li><strong>call</strong></li>
</ol>

<p>　　对象后面加括号，触发执行。</p>

<p>注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 <strong>call</strong> 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()</p>

<pre><code>
class Foo:



    def __init__(self):

        pass

    

    def __call__(self, *args, **kwargs):



        print '__call__'





obj = Foo() # 执行 __init__

obj()      # 执行 __call__

</code></pre>

<ol>
<li><strong>dict</strong></li>
</ol>

<p>　　类或对象中的所有成员</p>

<p>上文中我们知道：类的普通字段属于对象；类中的静态字段和方法等属于类.</p>

<ol>
<li><strong>str</strong></li>
</ol>

<p>　　如果一个类中定义了<strong>str</strong>方法，那么在打印 对象 时，默认输出该方法的返回值。</p>

<p>8、<strong>getitem</strong>、<strong>setitem</strong>、<strong>delitem</strong></p>

<p>用于索引操作，如字典。以上分别表示获取、设置、删除数据</p>

<p>9、<strong>getslice</strong>、<strong>setslice</strong>、<strong>delslice</strong></p>

<p>该三个方法用于分片操作，如：列表</p>

<ol>
<li><strong>iter</strong></li>
</ol>

<p>用于迭代器，之所以列表、字典、元组可以进行for循环，是因为类型内部定义了 <strong>iter</strong></p>

<p>11、<strong>new</strong> 和 <strong>metaclass</strong></p>

<pre><code>
class MyType(type):



    def __init__(self, what, bases=None, dict=None):

        super(MyType, self).__init__(what, bases, dict)



    def __call__(self, *args, **kwargs):

        obj = self.__new__(self, *args, **kwargs)



        self.__init__(obj)



class Foo(object):



    __metaclass__ = MyType



    def __init__(self, name):

        self.name = name



    def __new__(cls, *args, **kwargs):

        return object.__new__(cls, *args, **kwargs)



# 第一阶段：解释器从上到下执行代码创建Foo类

# 第二阶段：通过Foo类创建obj对象

obj = Foo()

</code></pre>

<h1 id="类成员修饰符">类成员修饰符</h1>

<p>类的所有成员在上一步骤中已经做了详细的介绍，对于每一个类的成员而言都有两种形式：</p>

<ul>
<li><p>公有成员，在任何地方都能访问</p></li>

<li><p>私有成员，只有在类的内部才能方法</p></li>
</ul>

<p><strong>私有成员和公有成员的定义不同</strong>：私有成员命名时，前两个字符是下划线。（特殊成员除外，例如：<strong>init</strong>、<strong>call</strong>、<strong>dict</strong>等）</p>

<pre><code>
class C:

 

    def __init__(self):

        self.name = '公有字段'

        self.__foo = &quot;私有字段&quot;

</code></pre>

<p><strong>私有成员和公有成员的访问限制不同</strong>：</p>

<p>静态字段</p>

<ul>
<li><p>公有静态字段：类可以访问；类内部可以访问；派生类中可以访问</p></li>

<li><p>私有静态字段：仅类内部可以访问；</p></li>
</ul>

<pre><code>
# 公有静态字段

class C:



    name = &quot;公有静态字段&quot;



    def func(self):

        print C.name



class D(C):



    def show(self):

        print C.name





C.name         # 类访问



obj = C()

obj.func()     # 类内部可以访问



obj_son = D()

obj_son.show() # 派生类中可以访问



# 私有静态字段

class C:



    __name = &quot;公有静态字段&quot;



    def func(self):

        print C.__name



class D(C):



    def show(self):

        print C.__name





C.__name       # 类访问            ==&gt; 错误



obj = C()

obj.func()     # 类内部可以访问     ==&gt; 正确



obj_son = D()

obj_son.show() # 派生类中可以访问   ==&gt; 错误

</code></pre>

<p>普通字段</p>

<ul>
<li><p>公有普通字段：对象可以访问；类内部可以访问；派生类中可以访问</p></li>

<li><p>私有普通字段：仅类内部可以访问；</p></li>
</ul>

<p>ps：如果想要强制访问私有字段，可以通过 【对象._类名<strong>私有字段明 】访问（如：obj._C</strong>foo），不建议强制访问私有成员。</p>

<pre><code>
# 公有字段

class C:

    

    def __init__(self):

        self.foo = &quot;公有字段&quot;



    def func(self):

        print self.foo 　#　类内部访问



class D(C):

    

    def show(self):

        print self.foo　＃　派生类中访问



obj = C()



obj.foo     # 通过对象访问

obj.func()  # 类内部访问



obj_son = D();

obj_son.show()  # 派生类中访问



#私有字段

class C:

    

    def __init__(self):

        self.__foo = &quot;私有字段&quot;



    def func(self):

        print self.foo 　#　类内部访问



class D(C):

    

    def show(self):

        print self.foo　＃　派生类中访问



obj = C()



obj.__foo     # 通过对象访问    ==&gt; 错误

obj.func()  # 类内部访问        ==&gt; 正确



obj_son = D();

obj_son.show()  # 派生类中访问  ==&gt; 错误



</code></pre>

<p>方法、属性的访问于上述方式相似，即：私有成员只能在类内部使用</p>

<p>ps：非要访问私有属性的话，可以通过 对象._类__属性名</p>

<h1 id="面向对象编程的本质">面向对象编程的本质</h1>

<ul>
<li>面向对象编程的本质就是<code>找名词</code>、<code>加属性</code>、<code>连关系</code>。</li>
</ul>

<h2 id="面向对象设计利器">面向对象设计利器</h2>

<p>很多同学都是学会了面向对象的语法，却依然写不出面向对象的程序，原因是什么呢？原因就是因为你还没掌握一门面向对象设计利器， 你说我读书少别骗我， 什么利器？
答案就是:领域建模。 从领域模型开始,我们就开始了面向对象的分析和设计过程,可以说,领域模型是完成从需求分析到面向 对象设计的一座桥梁。</p>

<p>领域模型,顾名思义,就是需求所涉及的领域的一个建模,更通俗的讲法是业务模型。 参考百度百科(<a href="http://baike.baidu.cn/view/757895.htm">http://baike.baidu.cn/view/757895.htm</a> ),领域模型定义如下:</p>

<p>从这个定义我们可以看出,领域模型有两个主要的作用:</p>

<p>1、发掘重要的业务领域概念
2、建立业务领域概念之间的关系</p>

<h2 id="领域建模三字经">领域建模三字经</h2>

<p>领域模型如此重要,很多同学可能会认为领域建模很复杂,需要很高的技巧。然而事实上领域建模非常简单,简单得有点难以让人相信,领域建模的方法概括一下就是“找名词”!
虽然我们说“找名词”很简单,但一个关键的问题还没有说明:从哪里找? 如果你还记得领域模型是“需求到面向对象的桥梁”,那么你肯定一下子就能想到:从需求模型中找,具体来说就是从用例中找。
归纳一下域建模的方法就是“从用例中找名词”。 当然,找到名词后,为了能够更加符合面向对象的要求和特点,我们还需要对这些名词进一步完善,这就 是接下来的步骤:加属性,连关系!
最后我们总结出领域建模的三字经方法:找名词、加属性、连关系。</p>

<h2 id="找名词">找名词</h2>

<p>who : 学员、讲师、管理员</p>

<p>用例：</p>

<ol>
<li><p>管理员 创建了 北京 和 上海 两个校区</p></li>

<li><p>管理员 创建了 Linux \ Python \ Go 3个课程</p></li>

<li><p>管理员 创建了 北京校区的Python 16期， Go开发第一期，和上海校区的Linux 36期 班级</p></li>

<li><p>管理员 创建了 北京校区的 学员 小晴 ，并将其 分配 在了 班级  python 16期</p></li>

<li><p>管理员 创建了 讲师 Alex , 并将其分配 给了 班级 python 16期 和全栈脱产5期</p></li>

<li><p>讲师 Alex 创建 了一条 python 16期的 上课纪录 Day6</p></li>

<li><p>讲师 Alex 为Day6这节课 所有的学员 批了作业 ，小晴得了A, 李磊得了C-, 严帅得了B</p></li>

<li><p>学员小晴 在 python 16 的 day6里 提交了作业</p></li>

<li><p>学员李磊 查看了自己所报的所有课程</p></li>
</ol>

<p>10 学员 李磊  在 查看了 自己在 py16期 的 成绩列表 ，然后自杀了</p>

<ol>
<li>学员小晴  跟 讲师 Alex 表白了</li>
</ol>

<p>名词列表：</p>

<p>管理员、校区、课程、班级、上课纪录、作业、成绩、讲师、学员</p>

<h2 id="加属性">加属性</h2>

<h2 id="连关系">连关系</h2>

<p>有了类,也有了属性,接下来自然就是找出它们的关系了。</p>

<p>参考文档：</p>

<p><a href="http://www.cnblogs.com/alex3714/articles/5188179.html">http://www.cnblogs.com/alex3714/articles/5188179.html</a></p>

<p><a href="http://www.cnblogs.com/wupeiqi/p/4493506.html">http://www.cnblogs.com/wupeiqi/p/4493506.html</a></p>

<p><a href="http://www.cnblogs.com/wupeiqi/p/4766801.html">http://www.cnblogs.com/wupeiqi/p/4766801.html</a></p>

            </article>

            <ul class="pager blog-pager">
                
                <li class="previous">
                    <a href="https://www.eee.wiki/posts/python%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/" data-toggle="tooltip" data-placement="top" title="Python常用标准库">&larr; Previous Post</a>
                </li>
                 
            </ul>
            
            <div>
                 
                <h2>See Also</h2>
                <ul>
                    
                    <li><a href="/posts/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/">Python文件处理</a></li>
                    
                    <li><a href="/posts/python%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/">Python常用标准库</a></li>
                    
                    <li><a href="/posts/python%E9%80%92%E5%BD%92%E5%92%8C%E5%8F%8D%E5%B0%84/">Python递归和反射</a></li>
                    
                    <li><a href="/posts/python%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/">Python函数和装饰器</a></li>
                    
                    <li><a href="/posts/python%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Python常用数据类型</a></li>
                    
                </ul>
                
            </div>
            
            
            
              
            </div>
            
            
        </div>
    </div>
    </section>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
        <img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft8a0o1hlcj30ax0azjt4.jpg">
          
              <li>
                <a href="mailto:976199267@qq.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/wtli/wtli.github.io" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
        </ul>
        <p class="credits copyright text-muted">
        &copy;2017-2018
          
            
              wangtian
            
          
          
          
            &nbsp;&bull;&nbsp;
            <a href="https://www.eee.wiki/">wtlinux</a>
          
        </p>
        <p class="credits theme-by text-muted">
        <a href="http://www.wtlinux.com">wtlinux.com</a>&nbsp;&bull;&nbsp;<a href="https://www.eee.wiki">eee.wiki</a>&nbsp;&bull;&nbsp;<a href="https://www.bldz.com">www.bldz.com</a>
        </p>

        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.41</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/rootsongjc/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>


<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/bootstrap.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/photoswipe-ui-default.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/photoswipe.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/auto-render.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/main.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/prism.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/katex.min.js"></script>
<script> renderMathInElement(document.body); </script>







  </body>
</html>

