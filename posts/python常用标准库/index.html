<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title> Python常用标准库 - wtlinux-职业生涯记录</title>
  <meta name="description" content="wtlinux-职业生涯记录" />
  <meta property="og:title" content="Python常用标准库" />
  <meta name="twitter:title" content="Python常用标准库" />
  <meta name="description" content="介绍一些常用的python标准库">
  <meta property="og:description" content="介绍一些常用的python标准库">
  <meta name="twitter:description" content="介绍一些常用的python标准库">
  <meta name="author" content="wangtian"/>
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://www.eee.wiki/posts/python%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="wtlinux" />

  <meta name="generator" content="Hugo 0.41" />
  <link rel="canonical" href="https://www.eee.wiki/posts/python%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/" />
  <link rel="alternate" href="https://www.eee.wiki/index.xml" type="application/rss+xml" title="wtlinux">
  <script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/jquery-1.12.4.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  
  
  <link rel="stylesheet" href="https://www.eee.wiki/css/main.css" />
  <link rel="stylesheet" href="https://www.eee.wiki/css/search.css" />
  
  

<meta name="baidu-site-verification" content="g8IYR9SNLF" />
<script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
    })();
</script>

<link rel="stylesheet" href="https://www.eee.wiki/css/prism.css" />




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css" integrity="sha256-sCl5PUOGMLfFYctzDW3MtRib0ctyUvI9Qsmq2wXOeBY=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css" integrity="sha256-BFeI1V+Vh1Rk37wswuOYn5lsTcaU96hGaI7OUVCLjPc=" crossorigin="anonymous" />



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://www.eee.wiki/">wtlinux</a>
    </div>
    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="Home" href="/home">Home</a>
              
              
            </li>
          
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent" href="javascript:void(0)">Categories</a>
              <div class="navlinks-children">
                
                
                  <a href="https://www.eee.wiki/tags/ops">ops</a>
                
                
                  <a href="https://www.eee.wiki/tags/dev">dev</a>
                
                
                  <a href="https://www.eee.wiki/tags/error">error</a>
                
                
                  <a href="https://www.eee.wiki/tags">Tags</a>
                
              </div>
            </li>
          
        
          
            <li>
              <a title="About" href="/about">About</a>
              
              
            </li>
          
        
          
            <li>
              <a title="talk" href="/tags/talk">talk</a>
              
              
            </li>
          
        

        

        
        
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
      </div>
    </div>

  </div>
</nav>






    
  
  
  




  
    <div id="header-big-imgs" data-num-img=1 data-img-src-1="https://ws2.sinaimg.cn/large/006tNc79gy1ftcuzmw47tj30hi08rgs2.jpg" data-img-desc-1="Shanghai China| 2018-07-19T14:56:33&#43;08:00"></div>
  

  <header class="header-section has-img">
    
      <div class="intro-header big-img">
        
        
        <div class="container">
          <div class="row">
              <div class="col-lg-12 col-md-12 col-md-offset-0">
                
                <div class="post-heading">
                
                  
                     <h1>Python常用标准库</h1>
                     
                     
                  
                  
                  
                    
                      <hr class="small">
                      <span class="post-subheading">标准库</span>
                    
                  
                  
                    <span class="post-meta">
  
  Posted on July 19, 2018
  
  
</span>


                  
                
              </div>
            </div>
          </div>
        </div>
        <span class="img-desc" style="display: inline;"></span>
      </div>
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-12 col-md-12 col-md-offset-0">
            <div class="posts-heading">
                <h1 align="center">Python常用标准库</h1>
                
                  
                    <h2 align="center" class="posts-subheading">标准库</h2>
                  
                
                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
<div class="container" role="main" itemscope itemtype="http://schema.org/Article">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            
            
              
            <article role="main" class="blog-post" itemprop="articleBody" id="content">
                
   
  <aside class="toc">
    <nav id="TableOfContents">
<ul>
<li><a href="#模块简介">模块简介</a>
<ul>
<li><a href="#模块分类">模块分类</a></li>
<li><a href="#导入模块">导入模块</a></li>
</ul></li>
<li><a href="#re">re</a>
<ul>
<li><a href="#元字符">元字符</a></li>
<li><a href="#match">match</a></li>
<li><a href="#deom">Deom</a></li>
<li><a href="#seach">seach</a></li>
<li><a href="#deom-1">Deom</a></li>
<li><a href="#findall">findall</a></li>
<li><a href="#deom-2">Deom</a></li>
<li><a href="#sub">sub</a></li>
<li><a href="#deom-3">Deom</a></li>
<li><a href="#split">split</a></li>
<li><a href="#deom-4">Deom</a></li>
<li><a href="#常用正则表达式">常用正则表达式</a></li>
<li><a href="#计算器的实现">计算器的实现</a></li>
<li><a href="#替换">替换</a></li>
</ul></li>
<li><a href="#os">os</a></li>
<li><a href="#sys">sys</a>
<ul>
<li><a href="#进度条">进度条</a></li>
</ul></li>
<li><a href="#subprocess">subprocess</a>
<ul>
<li><a href="#shell相关模块">shell相关模块</a></li>
<li><a href="#call">call</a></li>
<li><a href="#check-call">check_call</a></li>
<li><a href="#check-output">check_output</a></li>
<li><a href="#subprocess-popen">subprocess.Popen(&hellip;)</a></li>
<li><a href="#执行普通命令">执行普通命令</a></li>
</ul></li>
<li><a href="#shutil-shelve-itertools">shutil  shelve itertools</a>
<ul>
<li><a href="#shutil">shutil</a></li>
<li><a href="#zipfile解压缩">zipfile解压缩</a></li>
<li><a href="#tarfile解压缩">tarfile解压缩</a></li>
</ul></li>
<li><a href="#hashlib-密码加盐">hashlib(密码加盐)</a></li>
<li><a href="#logging">logging</a>
<ul>
<li><a href="#单文件日志">单文件日志</a></li>
<li><a href="#日志等级">日志等级：</a></li>
<li><a href="#日志记录格式">日志记录格式</a></li>
<li><a href="#多文件日志">多文件日志</a></li>
<li><a href="#日志一">日志一</a></li>
<li><a href="#日志二">日志二</a></li>
</ul></li>
<li><a href="#time">time</a>
<ul>
<li><a href="#格式化占位符">格式化占位符</a></li>
</ul></li>
<li><a href="#random">random</a>
<ul>
<li><a href="#随机验证码">随机验证码</a></li>
</ul></li>
<li><a href="#序列化-json-pickle-xml-yaml-configparser">序列化（json pickle xml yaml configparser）</a>
<ul>
<li><a href="#xml">xml</a></li>
</ul></li>
<li><a href="#first-xml">first.xml</a></li>
<li><a href="#解析xml">解析XML</a></li>
<li><a href="#操作xml">操作XML</a>
<ul>
<li><a href="#节点功能一览表">节点功能一览表</a></li>
<li><a href="#遍历xml文档的所有内容">遍历XML文档的所有内容</a></li>
<li><a href="#遍历xml中指定的节点">遍历XML中指定的节点</a></li>
<li><a href="#修改节点内容">修改节点内容</a></li>
<li><a href="#解析字符串方式-修改-保存">解析字符串方式，修改，保存</a></li>
<li><a href="#解析文件方式-修改-保存">解析文件方式，修改，保存</a></li>
<li><a href="#删除节点">删除节点</a></li>
<li><a href="#解析字符串方式-修改-保存-1">解析字符串方式，修改，保存</a></li>
<li><a href="#解析文件方式-修改-保存-1">解析文件方式，修改，保存</a></li>
</ul></li>
<li><a href="#创建xml文档">创建XML文档</a>
<ul>
<li><a href="#创建方式-一">创建方式（一）</a></li>
<li><a href="#创建方式-二">创建方式（二）</a></li>
<li><a href="#创建方式-三">创建方式（三）</a></li>
<li><a href="#命名空间">命名空间</a></li>
</ul></li>
<li><a href="#configparser">configparser</a>
<ul>
<li><a href="#指定格式">指定格式</a></li>
<li><a href="#获取所有节点">获取所有节点</a></li>
<li><a href="#获取指定节点下所有的键值对">获取指定节点下所有的键值对</a></li>
<li><a href="#获取指定节点下所有的键">获取指定节点下所有的键</a></li>
<li><a href="#获取指定节点下指定key的值">获取指定节点下指定key的值</a></li>
<li><a href="#检查-删除-添加节点">检查、删除、添加节点</a></li>
<li><a href="#检查-删除-设置指定组内的键值对">检查、删除、设置指定组内的键值对</a></li>
</ul></li>
<li><a href="#requests-urllib">requests（urllib）</a>
<ul>
<li><a href="#发送get请求">发送get请求</a></li>
<li><a href="#发送携带请求头的get请求">发送携带请求头的GET请求</a></li>
<li><a href="#安装模块">安装模块</a></li>
<li><a href="#使用模块">使用模块</a></li>
<li><a href="#http请求">http请求</a></li>
<li><a href="#post请求">post请求</a></li>
<li><a href="#其他请求">其他请求</a></li>
<li><a href="#http请求和xml实例">http请求和XML实例</a></li>
<li><a href="#viewcode1">ViewCode1</a></li>
<li><a href="#viewcode2">ViewCode2</a></li>
</ul></li>
<li><a href="#paramiko">paramiko</a>
<ul>
<li><a href="#下载安装">下载安装</a></li>
<li><a href="#模块使用">模块使用</a></li>
<li><a href="#执行命令-用户名-密码">执行命令-用户名+密码</a></li>
<li><a href="#执行命令-秘钥">执行命令-秘钥</a></li>
<li><a href="#上传或下载文件-用户名-密码">上传或下载文件-用户名+密码</a></li>
<li><a href="#上传或下载文件-秘钥">上传或下载文件-秘钥</a></li>
</ul></li>
</ul>
</nav>
  </aside>
   

                

<h1 id="模块简介">模块简介</h1>

<h2 id="模块分类">模块分类</h2>

<pre><code>自定义模块
第三方模块
内置模块

注意：自定义模块名不能以数字开头，并且避免与内置函数名相同
</code></pre>

<h2 id="导入模块">导入模块</h2>

<pre><code>import sys
form lib import content 
from lib import content as bbb    #模块设置别名
from lib.content import func1
## 自定义模块导入：
sys.path.append('D:')
</code></pre>

<h1 id="re">re</h1>

<h2 id="元字符">元字符</h2>

<p>python中re模块提供了正则表达式相关操作
字符：</p>

<pre><code>　　. 匹配除换行符以外的任意字符
　　\w	匹配字母或数字或下划线或汉字
　　\s	匹配任意的空白符
　　\d	匹配数字
　　\b	匹配单词的开始或结束
　　^	匹配字符串的开始
　　$	匹配字符串的结束
</code></pre>

<p>次数：</p>

<pre><code>　　* 重复零次或更多次
　　+	重复一次或更多次
　　?	重复零次或一次
　　{n}	重复n次
　　{n,}	重复n次或更多次
　　{n,m}	重复n到m次
</code></pre>

<h2 id="match">match</h2>

<pre><code># match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None
 
 
 match(pattern, string, flags=0)
 # pattern： 正则模型
 # string ： 要匹配的字符串
 # falgs  ： 匹配模式
     X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
     I  IGNORECASE  Perform case-insensitive matching.
     M  MULTILINE   &quot;^&quot; matches the beginning of lines (after a newline)
                    as well as the string.
                    &quot;$&quot; matches the end of lines (before a newline) as well
                    as the end of the string.
     S  DOTALL      &quot;.&quot; matches any character at all, including the newline.
 
     A  ASCII       For string patterns, make \w, \W, \b, \B, \d, \D
                    match the corresponding ASCII character categories
                    (rather than the whole Unicode categories, which is the
                    default).
                    For bytes patterns, this flag is the only available
                    behaviour and needn't be specified.
      
     L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
     U  UNICODE     For compatibility only. Ignored for string patterns (it
                    is the default), and forbidden for bytes patterns.

</code></pre>

<h2 id="deom">Deom</h2>

<pre><code>        # 无分组
        r = re.match(&quot;h\w+&quot;, origin)
        print(r.group())     # 获取匹配到的所有结果
        print(r.groups())    # 获取模型中匹配到的分组结果
        print(r.groupdict()) # 获取模型中匹配到的分组结果

        # 有分组

        # 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）

        r = re.match(&quot;h(\w+).*(?P&lt;name&gt;\d)$&quot;, origin)
        print(r.group())     # 获取匹配到的所有结果
        print(r.groups())    # 获取模型中匹配到的分组结果
        print(r.groupdict()) # 获取模型中匹配到的分组中所有执行了key的组

</code></pre>

<h2 id="seach">seach</h2>

<pre><code># search,浏览整个字符串去匹配第一个，未匹配成功返回None
# search(pattern, string, flags=0)

</code></pre>

<h2 id="deom-1">Deom</h2>

<pre><code>       r = re.search(&quot;a\w+&quot;, origin)
        print(r.group())     # 获取匹配到的所有结果
        print(r.groups())    # 获取模型中匹配到的分组结果
        print(r.groupdict()) # 获取模型中匹配到的分组结果

        # 有分组

        r = re.search(&quot;a(\w+).*(?P&lt;name&gt;\d)$&quot;, origin)
        print(r.group())     # 获取匹配到的所有结果
        print(r.groups())    # 获取模型中匹配到的分组结果
        print(r.groupdict()) # 获取模型中匹配到的分组中所有执行了key的组

</code></pre>

<h2 id="findall">findall</h2>

<pre><code># findall，获取非重复的匹配列表；如果有一个组则以列表形式返回，且每一个匹配均是字符串；如果模型中有多个组，则以列表形式返回，且每一个匹配均是元祖；
# 空的匹配也会包含在结果中
#findall(pattern, string, flags=0)

</code></pre>

<h2 id="deom-2">Deom</h2>

<pre><code>      # 无分组
        r = re.findall(&quot;a\w+&quot;,origin)
        print(r)

        # 有分组
        origin = &quot;hello alex bcd abcd lge acd 19&quot;
        r = re.findall(&quot;a((\w*)c)(d)&quot;, origin)
        print(r)

</code></pre>

<h2 id="sub">sub</h2>

<pre><code># sub，替换匹配成功的指定位置字符串
 
sub(pattern, repl, string, count=0, flags=0)
# pattern： 正则模型
# repl   ： 要替换的字符串或可执行对象
# string ： 要匹配的字符串
# count  ： 指定匹配个数
# flags  ： 匹配模式

</code></pre>

<h2 id="deom-3">Deom</h2>

<pre><code>     # 与分组无关

        origin = &quot;hello alex bcd alex lge alex acd 19&quot;
        r = re.sub(&quot;a\w+&quot;, &quot;999&quot;, origin, 2)
        print(r)

</code></pre>

<h2 id="split">split</h2>

<pre><code>     # 与分组无关

        origin = &quot;hello alex bcd alex lge alex acd 19&quot;
        r = re.sub(&quot;a\w+&quot;, &quot;999&quot;, origin, 2)
        print(r)

</code></pre>

<h2 id="deom-4">Deom</h2>

<pre><code>        # 无分组
        origin = &quot;hello alex bcd alex lge alex acd 19&quot;
        r = re.split(&quot;alex&quot;, origin, 1)
        print(r)

        # 有分组
        
        origin = &quot;hello alex bcd alex lge alex acd 19&quot;
        r1 = re.split(&quot;(alex)&quot;, origin, 1)
        print(r1)
        r2 = re.split(&quot;(al(ex))&quot;, origin, 1)
        print(r2)

</code></pre>

<h2 id="常用正则表达式">常用正则表达式</h2>

<pre><code>IP：
^(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}$
手机号：
^1[3|4|5|8][0-9]\d{8}$
邮箱：
[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+

</code></pre>

<pre><code>#!/usr/bin/env python
# -*- conding: utf-8 -*-
import re
#re.match()

'''
#无分组
origin = &quot;hello alex bcd alex lge alex acd 19&quot;
r = re.match(&quot;(?P&lt;n1&gt;h)(?P&lt;n2&gt;\w+)&quot;, origin)
print(r.group())    #获取匹配到的所有结果
# hello
print(r.groups())   #获取模型中匹配到的分组结果
# ('h', 'ello')
print(r.groupdict())    #获取模型中匹配到的分组结果
# {'n1': 'h', 'n2': 'ello'}

#有分组

# 为何要有分组?提取匹配成功的指定内容（先匹配公共全部正则，再匹配成功的局部内容提取出来）
origin = &quot;hello alex bcd alex lge alex acd 19&quot;

r = re.match(&quot;(?P&lt;n1&gt;h)(?P&lt;n2&gt;\w+)&quot;, origin)
print(r.group())    #获取匹配到的所有结果
# hello
print(r.groups())   #获取模型中匹配到的分组结果
# ('h', 'ello')
print(r.groupdict())    #获取模型中匹配到的分组中所有执行了key的组
# {'n1': 'h', 'n2': 'ello'}



origin = &quot;hello alex bcd alex lge alex acd 19&quot;


a = 'alex'
n = re.findall('(\w)(\w)(\w)(\w)*',a)
print(n)
n = re.findall('(\w){4}',a)
print(n)
</code></pre>

<h2 id="计算器的实现">计算器的实现</h2>

<pre><code>#!/usr/bin/env python
# -*- conding: utf-8 -*-
import re

def f1(ex):
    return 1

origin = &quot;1 - 2 * ( (60-30 + (-40.0/5) * (9-2*5/3 + 7 /3*99/4*2998 +10 * 568/14 )) -(-4*3)/ (16-3*2) )&quot;

while True:
    print(origin)
    result = re.split(&quot;\(([^()]+)\)&quot;, origin,1)
    if len(result) == 3:
        before = result[0]
        content = result[1]
        after = result[2]
        # before,content,after = result     #上面三行可以用此一行表示。
        r = f1(content)
        new_str = before + str() +after
        origin = new_str
    else:
        final = f1(origin)
        print(final)
        break
</code></pre>

<h2 id="替换">替换</h2>

<pre><code>origin = 'faldjfj1o2j3o1241231231241jldajfl'

new_str = re.sub('\d+','kkkk',origin)
print(new_str,count)
# faldjfjkkkkokkkkjkkkkokkkkjldajfl

new_str,count = re.subn('\d+','kkkk',origin)
print(new_str,count)
# faldjfjkkkkokkkkjkkkkokkkkjldajfl 4
</code></pre>

<h1 id="os">os</h1>

<p>用于提供系统级别的操作：</p>

<pre><code>os.getcwd()                 获取当前工作目录，即当前python脚本工作的目录路径
os.chdir(&quot;dirname&quot;)         改变当前脚本工作目录；相当于shell下cd
os.curdir                   返回当前目录: ('.')
os.pardir                   获取当前目录的父目录字符串名：('..')
os.makedirs('dir1/dir2')    可生成多层递归目录
os.removedirs('dirname1')   若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推
os.mkdir('dirname')         生成单级目录；相当于shell中mkdir dirname
os.rmdir('dirname')         删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname
os.listdir('dirname')       列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
os.remove()                 删除一个文件
os.rename(&quot;oldname&quot;,&quot;new&quot;)  重命名文件/目录
os.stat('path/filename')    获取文件/目录信息
os.sep                      操作系统特定的路径分隔符，win下为&quot;\\&quot;,Linux下为&quot;/&quot;
os.linesep                  当前平台使用的行终止符，win下为&quot;\t\n&quot;,Linux下为&quot;\n&quot;
os.pathsep                  用于分割文件路径的字符串
os.name                     字符串指示当前使用平台。win-&gt;'nt'; Linux-&gt;'posix'
os.system(&quot;bash command&quot;)   运行shell命令，直接显示
os.environ                  获取系统环境变量
os.path.abspath(path)       返回path规范化的绝对路径
os.path.split(path)         将path分割成目录和文件名二元组返回
os.path.dirname(path)       返回path的目录。其实就是os.path.split(path)的第一个元素
os.path.basename(path)      返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素
os.path.exists(path)        如果path存在，返回True；如果path不存在，返回False
os.path.isabs(path)         如果path是绝对路径，返回True
os.path.isfile(path)        如果path是一个存在的文件，返回True。否则返回False
os.path.isdir(path)         如果path是一个存在的目录，则返回True。否则返回False
os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略
os.path.getatime(path)      返回path所指向的文件或者目录的最后存取时间
os.path.getmtime(path)      返回path所指向的文件或者目录的最后修改时间

</code></pre>

<h1 id="sys">sys</h1>

<p>用于提供对Python解释器相关的操作:</p>

<pre><code>sys.argv           命令行参数List，第一个元素是程序本身路径
sys.exit(n)        退出程序，正常退出时exit(0)
sys.version        获取Python解释程序的版本信息
sys.maxint         最大的Int值
sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
sys.platform       返回操作系统平台名称
sys.stdin          输入相关
sys.stdout         输出相关
sys.stderror       错误相关

</code></pre>

<h2 id="进度条">进度条</h2>

<pre><code>#!/usr/bin/env python
# -*- conding: utf-8 -*-
import time
import datetime
import sys
# print(&quot;start to sleep...&quot;)
# time.sleep(5)   #停止5秒
# print('wake up ...')

'''
print(time.time())#时间戳从1970年1月1号到现在一共多少秒
# 1501159604.7809947

print(time.time())
# Thu Jul 27 20:46:44 2017

print(time.ctime())
print(time.ctime(time.time()-86400))
time_obj = time.gmtime(time.time()-86400)
print(time_obj)
# time.struct_time(tm_year=2017, tm_mon=7, tm_mday=26, tm_hour=12, tm_min=46, tm_sec=44, tm_wday=2, tm_yday=207, tm_isdst=0)

print(datetime.date.today())
# 2017-07-27

print(datetime.datetime.now())
# 2017-07-27 20:48:42.053559

print(datetime.datetime.now() + datetime.timedelta(days=10))
# 2017-08-06 20:52:44.091561
'''

for i in range(31):
    sys.stdout.write('\r')
    sys.stdout.write(&quot;%s%% | %s&quot; % (int(i/30*100),int(i/30*100)*'*'))
    sys.stdout.flush()
    time.sleep(0.3)
</code></pre>

<h1 id="subprocess">subprocess</h1>

<h2 id="shell相关模块">shell相关模块</h2>

<p>可以执行shell命令的相关模块和函数有：
- os.system
- os.spawn*
- os.popen*          &ndash;废弃
- popen2.*           &ndash;废弃
- commands.*      &ndash;废弃，3.x中被移除</p>

<pre><code>import commands

result = commands.getoutput('cmd')
result = commands.getstatus('cmd')
result = commands.getstatusoutput('cmd')
</code></pre>

<p>以上执行shell命令的相关的模块和函数的功能均在 subprocess 模块中实现，并提供了更丰富的功能。</p>

<h2 id="call">call</h2>

<pre><code>ret = subprocess.call([&quot;ls&quot;, &quot;-l&quot;], shell=False)
ret = subprocess.call(&quot;ls -l&quot;, shell=True)

</code></pre>

<h2 id="check-call">check_call</h2>

<pre><code>subprocess.check_call([&quot;ls&quot;, &quot;-l&quot;])
subprocess.check_call(&quot;exit 1&quot;, shell=True)

</code></pre>

<h2 id="check-output">check_output</h2>

<pre><code>subprocess.check_output([&quot;echo&quot;, &quot;Hello World!&quot;])
subprocess.check_output(&quot;exit 1&quot;, shell=True)

</code></pre>

<h2 id="subprocess-popen">subprocess.Popen(&hellip;)</h2>

<p>用于执行复杂的系统命令
参数：
- args：shell命令，可以是字符串或者序列类型（如：list，元组）
- bufsize：指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲
- stdin, stdout, stderr：分别表示程序的标准输入、输出、错误句柄
- preexec_fn：只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用
- close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。
- 所以不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。
- shell：同上
- cwd：用于设置子进程的当前目录
- env：用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。
- universal_newlines：不同系统的换行符不同，True -&gt; 同意使用 \n
- startupinfo与createionflags只在windows下有效
- 将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等</p>

<h2 id="执行普通命令">执行普通命令</h2>

<pre><code>import subprocess
ret1 = subprocess.Popen([&quot;mkdir&quot;,&quot;t1&quot;])
ret2 = subprocess.Popen(&quot;mkdir t2&quot;, shell=True)

</code></pre>

<p>终端输入的命令分为两种：
- 输入即可得到输出，如：ifconfig
- 输入进行某环境，依赖再输入，如：python</p>

<pre><code>import subprocess

obj = subprocess.Popen(&quot;mkdir t3&quot;, shell=True, cwd='/home/dev',)

</code></pre>

<pre><code>import subprocess

obj = subprocess.Popen([&quot;python&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
obj.stdin.write(&quot;print(1)\n&quot;)
obj.stdin.write(&quot;print(2)&quot;)
obj.stdin.close()

cmd_out = obj.stdout.read()
obj.stdout.close()
cmd_error = obj.stderr.read()
obj.stderr.close()

print(cmd_out)
print(cmd_error)

</code></pre>

<pre><code>import subprocess

obj = subprocess.Popen([&quot;python&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
obj.stdin.write(&quot;print(1)\n&quot;)
obj.stdin.write(&quot;print(2)&quot;)

out_error_list = obj.communicate()
print(out_error_list)

</code></pre>

<pre><code>import subprocess

obj = subprocess.Popen([&quot;python&quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
out_error_list = obj.communicate('print(&quot;hello&quot;)')
print(out_error_list)

</code></pre>

<h1 id="shutil-shelve-itertools">shutil  shelve itertools</h1>

<ul>
<li>高级的 文件、文件夹、压缩包 处理模块</li>
</ul>

<h2 id="shutil">shutil</h2>

<pre><code>shutil.copyfileobj(fsrc, fdst[, length])
将文件内容拷贝到另一个文件中

1
2
3
import shutil
 
shutil.copyfileobj(open('old.xml','r'), open('new.xml', 'w'))
shutil.copyfile(src, dst)
拷贝文件

1
shutil.copyfile('f1.log', 'f2.log')
shutil.copymode(src, dst)
仅拷贝权限。内容、组、用户均不变

1
shutil.copymode('f1.log', 'f2.log')
shutil.copystat(src, dst)
仅拷贝状态的信息，包括：mode bits, atime, mtime, flags

1
shutil.copystat('f1.log', 'f2.log')
shutil.copy(src, dst)
拷贝文件和权限

1
2
3
import shutil
 
shutil.copy('f1.log', 'f2.log')
shutil.copy2(src, dst)
拷贝文件和状态信息

1
2
3
import shutil
 
shutil.copy2('f1.log', 'f2.log')
shutil.ignore_patterns(*patterns)
shutil.copytree(src, dst, symlinks=False, ignore=None)
递归的去拷贝文件夹

1
2
3
import shutil
 
shutil.copytree('folder1', 'folder2', ignore=shutil.ignore_patterns('*.pyc', 'tmp*'))
shutil.rmtree(path[, ignore_errors[, onerror]])
递归的去删除文件

1
2
3
import shutil
 
shutil.rmtree('folder1')
shutil.move(src, dst)
递归的去移动文件，它类似mv命令，其实就是重命名。

1
2
3
import shutil
 
shutil.move('folder1', 'folder3')
shutil.make_archive(base_name, format,...)

创建压缩包并返回文件路径，例如：zip、tar

创建压缩包并返回文件路径，例如：zip、tar

base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，
如：www                        =&gt;保存至当前路径
如：/Users/wupeiqi/www =&gt;保存至/Users/wupeiqi/
format：	压缩包种类，“zip”, “tar”, “bztar”，“gztar”
root_dir：	要压缩的文件夹路径（默认当前目录）
owner：	用户，默认当前用户
group：	组，默认当前组
logger：	用于记录日志，通常是logging.Logger对象
1
2
3
4
5
6
7
8
#将 /Users/wupeiqi/Downloads/test 下的文件打包放置当前程序目录
import shutil
ret = shutil.make_archive(&quot;wwwwwwwwww&quot;, 'gztar', root_dir='/Users/wupeiqi/Downloads/test')
  
  
#将 /Users/wupeiqi/Downloads/test 下的文件打包放置 /Users/wupeiqi/目录
import shutil
ret = shutil.make_archive(&quot;/Users/wupeiqi/wwwwwwwwww&quot;, 'gztar', root_dir='/Users/wupeiqi/Downloads/test')
shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细：
</code></pre>

<h2 id="zipfile解压缩">zipfile解压缩</h2>

<pre><code>import zipfile

# 压缩
z = zipfile.ZipFile('laxi.zip', 'w')
z.write('a.log')
z.write('data.data')
z.close()

# 解压
z = zipfile.ZipFile('laxi.zip', 'r')
z.extractall()
z.close()    

</code></pre>

<h2 id="tarfile解压缩">tarfile解压缩</h2>

<pre><code># 压缩
tar = tarfile.open('your.tar','w')
tar.add('/Users/wupeiqi/PycharmProjects/bbs2.log', arcname='bbs2.log')
tar.add('/Users/wupeiqi/PycharmProjects/cmdb.log', arcname='cmdb.log')
tar.close()

# 解压
tar = tarfile.open('your.tar','r')
tar.extractall()  # 可设置解压地址
tar.close()
</code></pre>

<h1 id="hashlib-密码加盐">hashlib(密码加盐)</h1>

<p>用于加密相关的操作，代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法</p>

<pre><code>
import hashlib
 
# #### md5 ####
hash = hashlib.md5()
# help(hash.update)
hash.update(bytes('admin', encoding='utf-8'))
print(hash.hexdigest())
print(hash.digest())
 
 
#### sha1 ####
 
hash = hashlib.sha1()
hash.update(bytes('admin', encoding='utf-8'))
print(hash.hexdigest())
 
# #### sha256 ####
 
hash = hashlib.sha256()
hash.update(bytes('admin', encoding='utf-8'))
print(hash.hexdigest())
 
 
# #### sha384 ####
 
hash = hashlib.sha384()
hash.update(bytes('admin', encoding='utf-8'))
print(hash.hexdigest())
 
# #### sha512 ####
 
hash = hashlib.sha512()
hash.update(bytes('admin', encoding='utf-8'))
print(hash.hexdigest())

</code></pre>

<p>以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。</p>

<pre><code>import hashlib
 
# #### md5 ####
 
hash = hashlib.md5(bytes('898oaFs09f',encoding=&quot;utf-8&quot;))
hash.update(bytes('admin',encoding=&quot;utf-8&quot;))
print(hash.hexdigest())

</code></pre>

<p>python内置还有一个 hmac 模块，它内部对我们创建 key 和 内容 进行进一步的处理然后再加密</p>

<pre><code>import hmac
 
h = hmac.new(bytes('898oaFs09f',encoding=&quot;utf-8&quot;))
h.update(bytes('admin',encoding=&quot;utf-8&quot;))
print(h.hexdigest())
</code></pre>

<pre><code>#!/usr/bin/env python
# -*- conding: utf-8 -*-

import hashlib

def md5(arg):
    ooo = hashlib.md5(bytes('12fadjfk;aj',encoding='utf-8'))
    ooo.update(bytes(arg, encoding='utf-8'))
    return ooo.hexdigest()

def login(user,pwd):
    with open('db','r',encoding='utf-8') as f:
        for line in f:
            u, p = line.strip().split('|')
            if u == user and p == md5(pwd):
                return True

def register(user,pwd):
    with open('db','a',encoding='utf-8') as f:
        temp = user + '|' + md5(pwd)
        f.write(temp)


i = input('1,登陆；2，注册')
if i == '2':
    user = input('用户名:')
    pwd = input('密码:')
    register(user,pwd)
elif i == '1':
    user = input('用户名:')
    pwd = input('密码:')
    r = login(user,pwd)
    if r:
        print('登陆成功')
    else:
        print('登陆失败')

</code></pre>

<h1 id="logging">logging</h1>

<p>用于便捷记录日志且线程安全的模块</p>

<h2 id="单文件日志">单文件日志</h2>

<pre><code>import logging
  
  
logging.basicConfig(filename='log.log',
                    format='%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S %p',
                    level=10)
  
logging.debug('debug')
logging.info('info')
logging.warning('warning')
logging.error('error')
logging.critical('critical')
logging.log(10,'log')

</code></pre>

<h2 id="日志等级">日志等级：</h2>

<pre><code>CRITICAL = 50
FATAL = CRITICAL
ERROR = 40
WARNING = 30
WARN = WARNING
INFO = 20
DEBUG = 10
NOTSET = 0

</code></pre>

<p>注： <font color=red>只有【当前写等级】大于【日志等级】时，日志文件才被记录。</font></p>

<h2 id="日志记录格式">日志记录格式</h2>

<h2 id="多文件日志">多文件日志</h2>

<h2 id="日志一">日志一</h2>

<pre><code>import logging
# 定义文件
file_1_1 = logging.FileHandler('l1_1.log', 'a', encoding='utf-8')
fmt = logging.Formatter(fmt=&quot;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&quot;)
file_1_1.setFormatter(fmt)

file_1_2 = logging.FileHandler('l1_2.log', 'a', encoding='utf-8')
fmt = logging.Formatter()
file_1_2.setFormatter(fmt)

# 定义日志
logger1 = logging.Logger('s1', level=logging.ERROR)
logger1.addHandler(file_1_1)
logger1.addHandler(file_1_2)


# 写日志
logger1.critical('1111')

</code></pre>

<h2 id="日志二">日志二</h2>

<pre><code># 定义文件
file_2_1 = logging.FileHandler('l2_1.log', 'a')
fmt = logging.Formatter()
file_2_1.setFormatter(fmt)

# 定义日志
logger2 = logging.Logger('s2', level=logging.INFO)
logger2.addHandler(file_2_1

</code></pre>

<h1 id="time">time</h1>

<p>时间相关的操作，时间有三种表示方式：
- 时间戳               1970年1月1日之后的秒，即：time.time()
- 格式化的字符串    2014-11-11 11:11，    即：time.strftime(&lsquo;%Y-%m-%d&rsquo;)
- 结构化时间          元组包含了：年、日、星期等&hellip; time.struct_time    即：time.localtime()</p>

<pre><code>print time.time()
print time.mktime(time.localtime())
   
print time.gmtime()    #可加时间戳参数
print time.localtime() #可加时间戳参数
print time.strptime('2014-11-11', '%Y-%m-%d')
   
print time.strftime('%Y-%m-%d') #默认当前时间
print time.strftime('%Y-%m-%d',time.localtime()) #默认当前时间
print time.asctime()
print time.asctime(time.localtime())
print time.ctime(time.time())
   
import datetime
'''
datetime.date：表示日期的类。常用的属性有year, month, day
datetime.time：表示时间的类。常用的属性有hour, minute, second, microsecond
datetime.datetime：表示日期时间
datetime.timedelta：表示时间间隔，即两个时间点之间的长度
timedelta([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]])
strftime(&quot;%Y-%m-%d&quot;)
'''
import datetime
print datetime.datetime.now()
print datetime.datetime.now() - datetime.timedelta(days=5)

</code></pre>

<h2 id="格式化占位符">格式化占位符</h2>

<pre><code>    %Y  Year with century as a decimal number.
    %m  Month as a decimal number [01,12].
    %d  Day of the month as a decimal number [01,31].
    %H  Hour (24-hour clock) as a decimal number [00,23].
    %M  Minute as a decimal number [00,59].
    %S  Second as a decimal number [00,61].
    %z  Time zone offset from UTC.
    %a  Locale's abbreviated weekday name.
    %A  Locale's full weekday name.
    %b  Locale's abbreviated month name.
    %B  Locale's full month name.
    %c  Locale's appropriate date and time representation.
    %I  Hour (12-hour clock) as a decimal number [01,12].
    %p  Locale's equivalent of either AM or PM.

</code></pre>

<h1 id="random">random</h1>

<pre><code>import random
 
print(random.random())
print(random.randint(1, 2))
print(random.randrange(1, 10))

</code></pre>

<h2 id="随机验证码">随机验证码</h2>

<pre><code>import random
checkcode = ''
for i in range(4):
    current = random.randrange(0,4)
    if current != i:
        temp = chr(random.randint(65,90))
    else:
        temp = random.randint(0,9)
    checkcode += str(temp)
print checkcode

</code></pre>

<h1 id="序列化-json-pickle-xml-yaml-configparser">序列化（json pickle xml yaml configparser）</h1>

<p>Python中用于序列化的两个模块</p>

<p>json     用于【字符串】和 【python基本数据类型】 间进行转换
pickle   用于【python特有的类型】 和 【python基本数据类型】间进行转换
Json模块提供了四个功能：dumps、dump、loads、load</p>

<p>pickle模块提供了四个功能：dumps、dump、loads、load</p>

<pre><code>
import pickle

data = {'k1':123,'k2':'hello'}

# pickle.dumps 将数据通过特殊的形式转换为只有python语言认识的字符串

p_str = pickle.dumps(data)

print p_str

# pickle.dum 将数据通过特殊的形式转换为只有python语言认识的字符串，并写入文件

with open('D:/result.pk','w') as fd:

    pickle.dump(data,fd)



import json

# json.dumps 将数据通过特殊的形式转换为所有程序语言都认识的字符串

j_str = json.dumps(data)

print j_str



#json.dump 将数据通过特殊的形式转换为所有程序语言都认识的字符串，并写入文件

with open('D:/result.pk','w') as fd:

    json.dump(data,fd)

</code></pre>

<h2 id="xml">xml</h2>

<ul>
<li>XML是实现不同语言或程序之间进行数据交换的协议，XML文件格式如下：</li>
</ul>

<h1 id="first-xml">first.xml</h1>

<pre><code>&lt;data&gt;
    &lt;country name=&quot;Liechtenstein&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;2&lt;/rank&gt;
        &lt;year&gt;2023&lt;/year&gt;
        &lt;gdppc&gt;141100&lt;/gdppc&gt;
        &lt;neighbor direction=&quot;E&quot; name=&quot;Austria&quot; /&gt;
        &lt;neighbor direction=&quot;W&quot; name=&quot;Switzerland&quot; /&gt;
    &lt;/country&gt;
    &lt;country name=&quot;Singapore&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;5&lt;/rank&gt;
        &lt;year&gt;2026&lt;/year&gt;
        &lt;gdppc&gt;59900&lt;/gdppc&gt;
        &lt;neighbor direction=&quot;N&quot; name=&quot;Malaysia&quot; /&gt;
    &lt;/country&gt;
    &lt;country name=&quot;Panama&quot;&gt;
        &lt;rank updated=&quot;yes&quot;&gt;69&lt;/rank&gt;
        &lt;year&gt;2026&lt;/year&gt;
        &lt;gdppc&gt;13600&lt;/gdppc&gt;
        &lt;neighbor direction=&quot;W&quot; name=&quot;Costa Rica&quot; /&gt;
        &lt;neighbor direction=&quot;E&quot; name=&quot;Colombia&quot; /&gt;
    &lt;/country&gt;
&lt;/data&gt;

</code></pre>

<h1 id="解析xml">解析XML</h1>

<pre><code>from xml.etree import ElementTree as ET


# 打开文件，读取XML内容
str_xml = open('xo.xml', 'r').read()

# 将字符串解析成xml特殊对象，root代指xml文件的根节点
root = ET.XML(str_xml)

</code></pre>

<h1 id="操作xml">操作XML</h1>

<p>XML格式类型是节点嵌套节点，对于每一个节点均有以下功能，以便对当前节点进行操作：</p>

<h2 id="节点功能一览表">节点功能一览表</h2>

<pre><code>class Element:
    &quot;&quot;&quot;An XML element.

    This class is the reference implementation of the Element interface.

    An element's length is its number of subelements.  That means if you
    want to check if an element is truly empty, you should check BOTH
    its length AND its text attribute.

    The element tag, attribute names, and attribute values can be either
    bytes or strings.

    *tag* is the element name.  *attrib* is an optional dictionary containing
    element attributes. *extra* are additional element attributes given as
    keyword arguments.

    Example form:
        &lt;tag attrib&gt;text&lt;child/&gt;...&lt;/tag&gt;tail

    &quot;&quot;&quot;

    当前节点的标签名
    tag = None
    &quot;&quot;&quot;The element's name.&quot;&quot;&quot;

    当前节点的属性

    attrib = None
    &quot;&quot;&quot;Dictionary of the element's attributes.&quot;&quot;&quot;

    当前节点的内容
    text = None
    &quot;&quot;&quot;
    Text before first subelement. This is either a string or the value None.
    Note that if there is no text, this attribute may be either
    None or the empty string, depending on the parser.

    &quot;&quot;&quot;

    tail = None
    &quot;&quot;&quot;
    Text after this element's end tag, but before the next sibling element's
    start tag.  This is either a string or the value None.  Note that if there
    was no text, this attribute may be either None or an empty string,
    depending on the parser.

    &quot;&quot;&quot;

    def __init__(self, tag, attrib={}, **extra):
        if not isinstance(attrib, dict):
            raise TypeError(&quot;attrib must be dict, not %s&quot; % (
                attrib.__class__.__name__,))
        attrib = attrib.copy()
        attrib.update(extra)
        self.tag = tag
        self.attrib = attrib
        self._children = []

    def __repr__(self):
        return &quot;&lt;%s %r at %#x&gt;&quot; % (self.__class__.__name__, self.tag, id(self))

    def makeelement(self, tag, attrib):
        创建一个新节点
        &quot;&quot;&quot;Create a new element with the same type.

        *tag* is a string containing the element name.
        *attrib* is a dictionary containing the element attributes.

        Do not call this method, use the SubElement factory function instead.

        &quot;&quot;&quot;
        return self.__class__(tag, attrib)

    def copy(self):
        &quot;&quot;&quot;Return copy of current element.

        This creates a shallow copy. Subelements will be shared with the
        original tree.

        &quot;&quot;&quot;
        elem = self.makeelement(self.tag, self.attrib)
        elem.text = self.text
        elem.tail = self.tail
        elem[:] = self
        return elem

    def __len__(self):
        return len(self._children)

    def __bool__(self):
        warnings.warn(
            &quot;The behavior of this method will change in future versions.  &quot;
            &quot;Use specific 'len(elem)' or 'elem is not None' test instead.&quot;,
            FutureWarning, stacklevel=2
            )
        return len(self._children) != 0 # emulate old behaviour, for now

    def __getitem__(self, index):
        return self._children[index]

    def __setitem__(self, index, element):
        # if isinstance(index, slice):
        #     for elt in element:
        #         assert iselement(elt)
        # else:
        #     assert iselement(element)
        self._children[index] = element

    def __delitem__(self, index):
        del self._children[index]

    def append(self, subelement):
        为当前节点追加一个子节点
        &quot;&quot;&quot;Add *subelement* to the end of this element.

        The new element will appear in document order after the last existing
        subelement (or directly after the text, if it's the first subelement),
        but before the end tag for this element.

        &quot;&quot;&quot;
        self._assert_is_element(subelement)
        self._children.append(subelement)

    def extend(self, elements):
        为当前节点扩展 n 个子节点
        &quot;&quot;&quot;Append subelements from a sequence.

        *elements* is a sequence with zero or more elements.

        &quot;&quot;&quot;
        for element in elements:
            self._assert_is_element(element)
        self._children.extend(elements)

    def insert(self, index, subelement):
        在当前节点的子节点中插入某个节点，即：为当前节点创建子节点，然后插入指定位置
        &quot;&quot;&quot;Insert *subelement* at position *index*.&quot;&quot;&quot;
        self._assert_is_element(subelement)
        self._children.insert(index, subelement)

    def _assert_is_element(self, e):
        # Need to refer to the actual Python implementation, not the
        # shadowing C implementation.
        if not isinstance(e, _Element_Py):
            raise TypeError('expected an Element, not %s' % type(e).__name__)

    def remove(self, subelement):
        在当前节点在子节点中删除某个节点
        &quot;&quot;&quot;Remove matching subelement.

        Unlike the find methods, this method compares elements based on
        identity, NOT ON tag value or contents.  To remove subelements by
        other means, the easiest way is to use a list comprehension to
        select what elements to keep, and then use slice assignment to update
        the parent element.

        ValueError is raised if a matching element could not be found.

        &quot;&quot;&quot;
        # assert iselement(element)
        self._children.remove(subelement)

    def getchildren(self):
        获取所有的子节点（废弃）
        &quot;&quot;&quot;(Deprecated) Return all subelements.

        Elements are returned in document order.

        &quot;&quot;&quot;
        warnings.warn(
            &quot;This method will be removed in future versions.  &quot;
            &quot;Use 'list(elem)' or iteration over elem instead.&quot;,
            DeprecationWarning, stacklevel=2
            )
        return self._children

    def find(self, path, namespaces=None):
        获取第一个寻找到的子节点
        &quot;&quot;&quot;Find first matching element by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return the first matching element, or None if no element was found.

        &quot;&quot;&quot;
        return ElementPath.find(self, path, namespaces)

    def findtext(self, path, default=None, namespaces=None):
        获取第一个寻找到的子节点的内容
        &quot;&quot;&quot;Find text for first matching element by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *default* is the value to return if the element was not found,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return text content of first matching element, or default value if
        none was found.  Note that if an element is found having no text
        content, the empty string is returned.

        &quot;&quot;&quot;
        return ElementPath.findtext(self, path, default, namespaces)

    def findall(self, path, namespaces=None):
        获取所有的子节点
        &quot;&quot;&quot;Find all matching subelements by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Returns list containing all matching elements in document order.

        &quot;&quot;&quot;
        return ElementPath.findall(self, path, namespaces)

    def iterfind(self, path, namespaces=None):
        获取所有指定的节点，并创建一个迭代器（可以被for循环）
        &quot;&quot;&quot;Find all matching subelements by tag name or path.

        *path* is a string having either an element tag or an XPath,
        *namespaces* is an optional mapping from namespace prefix to full name.

        Return an iterable yielding all matching elements in document order.

        &quot;&quot;&quot;
        return ElementPath.iterfind(self, path, namespaces)

    def clear(self):
        清空节点
        &quot;&quot;&quot;Reset element.

        This function removes all subelements, clears all attributes, and sets
        the text and tail attributes to None.

        &quot;&quot;&quot;
        self.attrib.clear()
        self._children = []
        self.text = self.tail = None

    def get(self, key, default=None):
        获取当前节点的属性值
        &quot;&quot;&quot;Get element attribute.

        Equivalent to attrib.get, but some implementations may handle this a
        bit more efficiently.  *key* is what attribute to look for, and
        *default* is what to return if the attribute was not found.

        Returns a string containing the attribute value, or the default if
        attribute was not found.

        &quot;&quot;&quot;
        return self.attrib.get(key, default)

    def set(self, key, value):
        为当前节点设置属性值
        &quot;&quot;&quot;Set element attribute.

        Equivalent to attrib[key] = value, but some implementations may handle
        this a bit more efficiently.  *key* is what attribute to set, and
        *value* is the attribute value to set it to.

        &quot;&quot;&quot;
        self.attrib[key] = value

    def keys(self):
        获取当前节点的所有属性的 key

        &quot;&quot;&quot;Get list of attribute names.

        Names are returned in an arbitrary order, just like an ordinary
        Python dict.  Equivalent to attrib.keys()

        &quot;&quot;&quot;
        return self.attrib.keys()

    def items(self):
        获取当前节点的所有属性值，每个属性都是一个键值对
        &quot;&quot;&quot;Get element attributes as a sequence.

        The attributes are returned in arbitrary order.  Equivalent to
        attrib.items().

        Return a list of (name, value) tuples.

        &quot;&quot;&quot;
        return self.attrib.items()

    def iter(self, tag=None):
        在当前节点的子孙中根据节点名称寻找所有指定的节点，并返回一个迭代器（可以被for循环）。
        &quot;&quot;&quot;Create tree iterator.

        The iterator loops over the element and all subelements in document
        order, returning all elements with a matching tag.

        If the tree structure is modified during iteration, new or removed
        elements may or may not be included.  To get a stable set, use the
        list() function on the iterator, and loop over the resulting list.

        *tag* is what tags to look for (default is to return all elements)

        Return an iterator containing all the matching elements.

        &quot;&quot;&quot;
        if tag == &quot;*&quot;:
            tag = None
        if tag is None or self.tag == tag:
            yield self
        for e in self._children:
            yield from e.iter(tag)

    # compatibility
    def getiterator(self, tag=None):
        # Change for a DeprecationWarning in 1.4
        warnings.warn(
            &quot;This method will be removed in future versions.  &quot;
            &quot;Use 'elem.iter()' or 'list(elem.iter())' instead.&quot;,
            PendingDeprecationWarning, stacklevel=2
        )
        return list(self.iter(tag))

    def itertext(self):
        在当前节点的子孙中根据节点名称寻找所有指定的节点的内容，并返回一个迭代器（可以被for循环）。
        &quot;&quot;&quot;Create text iterator.

        The iterator loops over the element and all subelements in document
        order, returning all inner text.

        &quot;&quot;&quot;
        tag = self.tag
        if not isinstance(tag, str) and tag is not None:
            return
        if self.text:
            yield self.text
        for e in self:
            yield from e.itertext()
            if e.tail:
                yield e.tail

</code></pre>

<ul>
<li>由于 每个节点 都具有以上的方法，并且在上一步骤中解析时均得到了root（xml文件的根节点），so   可以利用以上方法进行操作xml文件。</li>
</ul>

<h2 id="遍历xml文档的所有内容">遍历XML文档的所有内容</h2>

<pre><code>from xml.etree import ElementTree as ET

###### 解析方式一 ######
&quot;&quot;&quot;
# 打开文件，读取XML内容
str_xml = open('xo.xml', 'r').read()

# 将字符串解析成xml特殊对象，root代指xml文件的根节点
root = ET.XML(str_xml)
&quot;&quot;&quot;
###### 解析方式二 ######

# 直接解析xml文件
tree = ET.parse(&quot;xo.xml&quot;)

# 获取xml文件的根节点
root = tree.getroot()


## 操作

# 顶层标签
print(root.tag)


# 遍历XML文档的第二层
for child in root:
    # 第二层节点的标签名称和标签属性
    print(child.tag, child.attrib)
    # 遍历XML文档的第三层
    for i in child:
        # 第二层节点的标签名称和内容
        print(i.tag,i.text)

</code></pre>

<h2 id="遍历xml中指定的节点">遍历XML中指定的节点</h2>

<pre><code>from xml.etree import ElementTree as ET

###### 解析方式一 ######
&quot;&quot;&quot;
# 打开文件，读取XML内容
str_xml = open('xo.xml', 'r').read()

# 将字符串解析成xml特殊对象，root代指xml文件的根节点
root = ET.XML(str_xml)
&quot;&quot;&quot;
###### 解析方式二 ######

# 直接解析xml文件
tree = ET.parse(&quot;xo.xml&quot;)

# 获取xml文件的根节点
root = tree.getroot()


## 操作

# 顶层标签
print(root.tag)


# 遍历XML中所有的year节点
for node in root.iter('year'):
    # 节点的标签名称和内容
    print(node.tag, node.text)

</code></pre>

<h2 id="修改节点内容">修改节点内容</h2>

<ul>
<li>由于修改的节点时，均是在内存中进行，其不会影响文件中的内容。所以，如果想要修改，则需要重新将内存中的内容写到文件。</li>
</ul>

<h2 id="解析字符串方式-修改-保存">解析字符串方式，修改，保存</h2>

<pre><code>from xml.etree import ElementTree as ET

###### 解析方式一 ######

# 打开文件，读取XML内容
str_xml = open('xo.xml', 'r').read()

# 将字符串解析成xml特殊对象，root代指xml文件的根节点
root = ET.XML(str_xml)

###### 操作 ######

# 顶层标签
print(root.tag)

# 循环所有的year节点
for node in root.iter('year'):
    # 将year节点中的内容自增一
    new_year = int(node.text) + 1
    node.text = str(new_year)

    # 设置属性
    node.set('name', 'alex')
    node.set('age', '18')
    # 删除属性
    del node.attrib['name']


###### 保存文件 ######
tree = ET.ElementTree(root)
tree.write(&quot;newnew.xml&quot;, encoding='utf-8')

</code></pre>

<h2 id="解析文件方式-修改-保存">解析文件方式，修改，保存</h2>

<pre><code>from xml.etree import ElementTree as ET

###### 解析方式二 ######

# 直接解析xml文件
tree = ET.parse(&quot;xo.xml&quot;)

# 获取xml文件的根节点
root = tree.getroot()

###### 操作 ######

# 顶层标签
print(root.tag)

# 循环所有的year节点
for node in root.iter('year'):
    # 将year节点中的内容自增一
    new_year = int(node.text) + 1
    node.text = str(new_year)

    # 设置属性
    node.set('name', 'alex')
    node.set('age', '18')
    # 删除属性
    del node.attrib['name']


###### 保存文件 ######
tree.write(&quot;newnew.xml&quot;, encoding='utf-8')

</code></pre>

<h2 id="删除节点">删除节点</h2>

<h2 id="解析字符串方式-修改-保存-1">解析字符串方式，修改，保存</h2>

<pre><code>from xml.etree import ElementTree as ET

###### 解析字符串方式打开 ######

# 打开文件，读取XML内容
str_xml = open('xo.xml', 'r').read()

# 将字符串解析成xml特殊对象，root代指xml文件的根节点
root = ET.XML(str_xml)

###### 操作 ######

# 顶层标签
print(root.tag)

# 遍历data下的所有country节点
for country in root.findall('country'):
    # 获取每一个country节点下rank节点的内容
    rank = int(country.find('rank').text)

    if rank &gt; 50:
        # 删除指定country节点
        root.remove(country)

###### 保存文件 ######
tree = ET.ElementTree(root)
tree.write(&quot;newnew.xml&quot;, encoding='utf-8')

</code></pre>

<h2 id="解析文件方式-修改-保存-1">解析文件方式，修改，保存</h2>

<pre><code>from xml.etree import ElementTree as ET

###### 解析文件方式 ######

# 直接解析xml文件
tree = ET.parse(&quot;xo.xml&quot;)

# 获取xml文件的根节点
root = tree.getroot()

###### 操作 ######

# 顶层标签
print(root.tag)

# 遍历data下的所有country节点
for country in root.findall('country'):
    # 获取每一个country节点下rank节点的内容
    rank = int(country.find('rank').text)

    if rank &gt; 50:
        # 删除指定country节点
        root.remove(country)

###### 保存文件 ######
tree.write(&quot;newnew.xml&quot;, encoding='utf-8')

</code></pre>

<h1 id="创建xml文档">创建XML文档</h1>

<h2 id="创建方式-一">创建方式（一）</h2>

<pre><code>from xml.etree import ElementTree as ET


# 创建根节点
root = ET.Element(&quot;famliy&quot;)


# 创建节点大儿子
son1 = ET.Element('son', {'name': '儿1'})
# 创建小儿子
son2 = ET.Element('son', {&quot;name&quot;: '儿2'})

# 在大儿子中创建两个孙子
grandson1 = ET.Element('grandson', {'name': '儿11'})
grandson2 = ET.Element('grandson', {'name': '儿12'})
son1.append(grandson1)
son1.append(grandson2)


# 把儿子添加到根节点中
root.append(son1)
root.append(son1)

tree = ET.ElementTree(root)
tree.write('oooo.xml',encoding='utf-8', short_empty_elements=False)

</code></pre>

<h2 id="创建方式-二">创建方式（二）</h2>

<pre><code>from xml.etree import ElementTree as ET

# 创建根节点
root = ET.Element(&quot;famliy&quot;)


# 创建大儿子
# son1 = ET.Element('son', {'name': '儿1'})
son1 = root.makeelement('son', {'name': '儿1'})
# 创建小儿子
# son2 = ET.Element('son', {&quot;name&quot;: '儿2'})
son2 = root.makeelement('son', {&quot;name&quot;: '儿2'})

# 在大儿子中创建两个孙子
# grandson1 = ET.Element('grandson', {'name': '儿11'})
grandson1 = son1.makeelement('grandson', {'name': '儿11'})
# grandson2 = ET.Element('grandson', {'name': '儿12'})
grandson2 = son1.makeelement('grandson', {'name': '儿12'})

son1.append(grandson1)
son1.append(grandson2)


# 把儿子添加到根节点中
root.append(son1)
root.append(son1)

tree = ET.ElementTree(root)
tree.write('oooo.xml',encoding='utf-8', short_empty_elements=False)

</code></pre>

<h2 id="创建方式-三">创建方式（三）</h2>

<pre><code>from xml.etree import ElementTree as ET


# 创建根节点
root = ET.Element(&quot;famliy&quot;)


# 创建节点大儿子
son1 = ET.SubElement(root, &quot;son&quot;, attrib={'name': '儿1'})
# 创建小儿子
son2 = ET.SubElement(root, &quot;son&quot;, attrib={&quot;name&quot;: &quot;儿2&quot;})

# 在大儿子中创建一个孙子
grandson1 = ET.SubElement(son1, &quot;age&quot;, attrib={'name': '儿11'})
grandson1.text = '孙子'


et = ET.ElementTree(root)  #生成文档对象
et.write(&quot;test.xml&quot;, encoding=&quot;utf-8&quot;, xml_declaration=True, short_empty_elements=False)

</code></pre>

<ul>
<li>由于原生保存的XML时默认无缩进，如果想要设置缩进的话， 需要修改保存方式：</li>
</ul>

<pre><code>from xml.etree import ElementTree as ET
from xml.dom import minidom


def prettify(elem):
    &quot;&quot;&quot;将节点转换成字符串，并添加缩进。
    &quot;&quot;&quot;
    rough_string = ET.tostring(elem, 'utf-8')
    reparsed = minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent=&quot;\t&quot;)

# 创建根节点
root = ET.Element(&quot;famliy&quot;)


# 创建大儿子
# son1 = ET.Element('son', {'name': '儿1'})
son1 = root.makeelement('son', {'name': '儿1'})
# 创建小儿子
# son2 = ET.Element('son', {&quot;name&quot;: '儿2'})
son2 = root.makeelement('son', {&quot;name&quot;: '儿2'})

# 在大儿子中创建两个孙子
# grandson1 = ET.Element('grandson', {'name': '儿11'})
grandson1 = son1.makeelement('grandson', {'name': '儿11'})
# grandson2 = ET.Element('grandson', {'name': '儿12'})
grandson2 = son1.makeelement('grandson', {'name': '儿12'})

son1.append(grandson1)
son1.append(grandson2)


# 把儿子添加到根节点中
root.append(son1)
root.append(son1)


raw_str = prettify(root)

f = open(&quot;xxxoo.xml&quot;,'w',encoding='utf-8')
f.write(raw_str)
f.close()

</code></pre>

<h2 id="命名空间">命名空间</h2>

<ul>
<li>详细介绍，<a href="http://www.w3school.com.cn/xml/xml_namespaces.asp">猛击这里</a></li>
</ul>

<pre><code>from xml.etree import ElementTree as ET

ET.register_namespace('com',&quot;http://www.company.com&quot;) #some name

# build a tree structure
root = ET.Element(&quot;{http://www.company.com}STUFF&quot;)
body = ET.SubElement(root, &quot;{http://www.company.com}MORE_STUFF&quot;, attrib={&quot;{http://www.company.com}hhh&quot;: &quot;123&quot;})
body.text = &quot;STUFF EVERYWHERE!&quot;

# wrap it in an ElementTree instance, and save as XML
tree = ET.ElementTree(root)

tree.write(&quot;page.xml&quot;,
           xml_declaration=True,
           encoding='utf-8',
           method=&quot;xml&quot;)

</code></pre>

<h1 id="configparser">configparser</h1>

<ul>
<li>configparser用于处理特定格式的文件，其本质上是利用open来操作文件。</li>
</ul>

<h2 id="指定格式">指定格式</h2>

<pre><code># 注释1
;  注释2

[section1] # 节点
k1 = v1    # 值
k2:v2      # 值

[section2] # 节点
k1 = v1    # 值

指定格式
</code></pre>

<h2 id="获取所有节点">获取所有节点</h2>

<pre><code>import configparser
 
config = configparser.ConfigParser()
config.read('xxxooo', encoding='utf-8')
ret = config.sections()
print(ret)

</code></pre>

<h2 id="获取指定节点下所有的键值对">获取指定节点下所有的键值对</h2>

<pre><code>config = configparser.ConfigParser()
config.read('xxxooo', encoding='utf-8')
ret = config.items('section1')
print(ret)

</code></pre>

<h2 id="获取指定节点下所有的键">获取指定节点下所有的键</h2>

<pre><code>import configparser
 
config = configparser.ConfigParser()
config.read('xxxooo', encoding='utf-8')
ret = config.options('section1')
print(ret)

</code></pre>

<h2 id="获取指定节点下指定key的值">获取指定节点下指定key的值</h2>

<pre><code>import configparser
 
config = configparser.ConfigParser()
config.read('xxxooo', encoding='utf-8')
 
 
v = config.get('section1', 'k1')
# v = config.getint('section1', 'k1')
# v = config.getfloat('section1', 'k1')
# v = config.getboolean('section1', 'k1')
 
print(v)

</code></pre>

<h2 id="检查-删除-添加节点">检查、删除、添加节点</h2>

<pre><code>import configparser
 
config = configparser.ConfigParser()
config.read('xxxooo', encoding='utf-8')
 
 
# 检查
has_sec = config.has_section('section1')
print(has_sec)
 
# 添加节点
config.add_section(&quot;SEC_1&quot;)
config.write(open('xxxooo', 'w'))
 
# 删除节点
config.remove_section(&quot;SEC_1&quot;)
config.write(open('xxxooo', 'w'))

</code></pre>

<h2 id="检查-删除-设置指定组内的键值对">检查、删除、设置指定组内的键值对</h2>

<pre><code>import configparser
 
config = configparser.ConfigParser()
config.read('xxxooo', encoding='utf-8')
 
# 检查
has_opt = config.has_option('section1', 'k1')
print(has_opt)
 
# 删除
config.remove_option('section1', 'k1')
config.write(open('xxxooo', 'w'))
 
# 设置
config.set('section1', 'k10', &quot;123&quot;)
config.write(open('xxxooo', 'w'))

</code></pre>

<h1 id="requests-urllib">requests（urllib）</h1>

<p>Python标准库中提供了：urllib等模块以供Http请求，但是，它的 API 太渣了。它是为另一个时代、另一个互联网所创建的。它需要巨量的工作，甚至包括各种方法覆盖，来完成最简单的任务。</p>

<h2 id="发送get请求">发送get请求</h2>

<pre><code>import urllib.request


f = urllib.request.urlopen('http://www.webxml.com.cn//webservices/qqOnlineWebService.asmx/qqCheckOnline?qqCode=424662508')
result = f.read().decode('utf-8')

</code></pre>

<h2 id="发送携带请求头的get请求">发送携带请求头的GET请求</h2>

<pre><code>import urllib.request

req = urllib.request.Request('http://www.example.com/')
req.add_header('Referer', 'http://www.python.org/')
r = urllib.request.urlopen(req)

result = f.read().decode('utf-8')

</code></pre>

<p>注：更多见Python官方文档：<a href="https://docs.python.org/3.5/library/urllib.request.html#module-urllib.request">https://docs.python.org/3.5/library/urllib.request.html#module-urllib.request</a>
Requests 是使用 Apache2 Licensed 许可证的 基于Python开发的HTTP 库，其在Python内置模块的基础上进行了高度的封装，从而使得Pythoner进行网络请求时，变得美好了许多，使用Requests可以轻而易举的完成浏览器可有的任何操作。</p>

<h2 id="安装模块">安装模块</h2>

<pre><code>pip3 install requests
</code></pre>

<h2 id="使用模块">使用模块</h2>

<h2 id="http请求">http请求</h2>

<pre><code># 1、无参数实例
 
import requests
 
ret = requests.get('https://github.com/timeline.json')
 
print(ret.url)
print(ret.text)
 
 
 
# 2、有参数实例
 
import requests
 
payload = {'key1': 'value1', 'key2': 'value2'}
ret = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)
 
print(ret.url)
print(ret.text)

</code></pre>

<h2 id="post请求">post请求</h2>

<pre><code># 1、基本POST实例
 
import requests
 
payload = {'key1': 'value1', 'key2': 'value2'}
ret = requests.post(&quot;http://httpbin.org/post&quot;, data=payload)
 
print(ret.text)
 
 
# 2、发送请求头和数据实例
 
import requests
import json
 
url = 'https://api.github.com/some/endpoint'
payload = {'some': 'data'}
headers = {'content-type': 'application/json'}
 
ret = requests.post(url, data=json.dumps(payload), headers=headers)
 
print(ret.text)
print(ret.cookies)

</code></pre>

<h2 id="其他请求">其他请求</h2>

<pre><code>requests.get(url, params=None, **kwargs)
requests.post(url, data=None, json=None, **kwargs)
requests.put(url, data=None, **kwargs)
requests.head(url, **kwargs)
requests.delete(url, **kwargs)
requests.patch(url, data=None, **kwargs)
requests.options(url, **kwargs)
 
# 以上方法均是在此方法的基础上构建
requests.request(method, url, **kwargs)

</code></pre>

<p>更多requests模块相关的文档见：<a href="http://cn.python-requests.org/zh_CN/latest/">http://cn.python-requests.org/zh_CN/latest/</a></p>

<h2 id="http请求和xml实例">http请求和XML实例</h2>

<p>实例：检测QQ账号是否在线</p>

<h2 id="viewcode1">ViewCode1</h2>

<pre><code>import urllib
import requests
from xml.etree import ElementTree as ET

# 使用内置模块urllib发送HTTP请求，或者XML格式内容
&quot;&quot;&quot;
f = urllib.request.urlopen('http://www.webxml.com.cn//webservices/qqOnlineWebService.asmx/qqCheckOnline?qqCode=424662508')
result = f.read().decode('utf-8')
&quot;&quot;&quot;


# 使用第三方模块requests发送HTTP请求，或者XML格式内容
r = requests.get('http://www.webxml.com.cn//webservices/qqOnlineWebService.asmx/qqCheckOnline?qqCode=424662508')
result = r.text

# 解析XML格式内容
node = ET.XML(result)

# 获取内容
if node.text == &quot;Y&quot;:
    print(&quot;在线&quot;)
else:
    print(&quot;离线&quot;)

</code></pre>

<h2 id="viewcode2">ViewCode2</h2>

<pre><code>import urllib
import requests
from xml.etree import ElementTree as ET

# 使用内置模块urllib发送HTTP请求，或者XML格式内容
&quot;&quot;&quot;
f = urllib.request.urlopen('http://www.webxml.com.cn/WebServices/TrainTimeWebService.asmx/getDetailInfoByTrainCode?TrainCode=G666&amp;UserID=')
result = f.read().decode('utf-8')
&quot;&quot;&quot;

# 使用第三方模块requests发送HTTP请求，或者XML格式内容
r = requests.get('http://www.webxml.com.cn/WebServices/TrainTimeWebService.asmx/getDetailInfoByTrainCode?TrainCode=G666&amp;UserID=')
result = r.text

# 解析XML格式内容
root = ET.XML(result)
for node in root.iter('TrainDetailInfo'):
    print(node.find('TrainStation').text,node.find('StartTime').text,node.tag,node.attrib)

</code></pre>

<p>注：[更多接口猛击这里]<a href="http://www.cnblogs.com/wupeiqi/archive/2012/11/18/2776014.html">http://www.cnblogs.com/wupeiqi/archive/2012/11/18/2776014.html</a></p>

<h1 id="paramiko">paramiko</h1>

<p>paramiko是一个用于做远程控制的模块，使用该模块可以对远程服务器进行命令或文件操作，值得一说的是，fabric和ansible内部的远程管理就是使用的paramiko来现实。</p>

<h2 id="下载安装">下载安装</h2>

<pre><code>pycrypto，由于 paramiko 模块内部依赖pycrypto，所以先下载安装pycrypto
pip3 install pycrypto
pip3 install paramiko
</code></pre>

<h2 id="模块使用">模块使用</h2>

<h2 id="执行命令-用户名-密码">执行命令-用户名+密码</h2>

<pre><code>#!/usr/bin/env python
#coding:utf-8

import paramiko

ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect('192.168.1.108', 22, 'alex', '123')
stdin, stdout, stderr = ssh.exec_command('df')
print stdout.read()
ssh.close();

</code></pre>

<h2 id="执行命令-秘钥">执行命令-秘钥</h2>

<pre><code>import paramiko

private_key_path = '/home/auto/.ssh/id_rsa'
key = paramiko.RSAKey.from_private_key_file(private_key_path)

ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect('主机名 ', 端口, '用户名', key)

stdin, stdout, stderr = ssh.exec_command('df')
print stdout.read()
ssh.close()

</code></pre>

<h2 id="上传或下载文件-用户名-密码">上传或下载文件-用户名+密码</h2>

<pre><code>import os,sys
import paramiko

t = paramiko.Transport(('182.92.219.86',22))
t.connect(username='wupeiqi',password='123')
sftp = paramiko.SFTPClient.from_transport(t)
sftp.put('/tmp/test.py','/tmp/test.py') 
t.close()


import os,sys
import paramiko

t = paramiko.Transport(('182.92.219.86',22))
t.connect(username='wupeiqi',password='123')
sftp = paramiko.SFTPClient.from_transport(t)
sftp.get('/tmp/test.py','/tmp/test2.py')
t.close(

</code></pre>

<h2 id="上传或下载文件-秘钥">上传或下载文件-秘钥</h2>

<pre><code>import paramiko

pravie_key_path = '/home/auto/.ssh/id_rsa'
key = paramiko.RSAKey.from_private_key_file(pravie_key_path)

t = paramiko.Transport(('182.92.219.86',22))
t.connect(username='wupeiqi',pkey=key)

sftp = paramiko.SFTPClient.from_transport(t)
sftp.put('/tmp/test3.py','/tmp/test3.py') 

t.close()

import paramiko

pravie_key_path = '/home/auto/.ssh/id_rsa'
key = paramiko.RSAKey.from_private_key_file(pravie_key_path)

t = paramiko.Transport(('182.92.219.86',22))
t.connect(username='wupeiqi',pkey=key)

sftp = paramiko.SFTPClient.from_transport(t)
sftp.get('/tmp/test3.py','/tmp/test4.py') 

t.close()

</code></pre>

            </article>

            <ul class="pager blog-pager">
                
                <li class="previous">
                    <a href="https://www.eee.wiki/posts/python%E9%80%92%E5%BD%92%E5%92%8C%E5%8F%8D%E5%B0%84/" data-toggle="tooltip" data-placement="top" title="Python递归和反射">&larr; Previous Post</a>
                </li>
                 
                <li class="next">
                    <a href="https://www.eee.wiki/posts/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" data-toggle="tooltip" data-placement="top" title="Python面向对象编程">Next Post &rarr;</a>
                </li>
                
            </ul>
            
            <div>
                 
                <h2>See Also</h2>
                <ul>
                    
                    <li><a href="/posts/python%E9%80%92%E5%BD%92%E5%92%8C%E5%8F%8D%E5%B0%84/">Python递归和反射</a></li>
                    
                    <li><a href="/posts/python%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/">Python函数和装饰器</a></li>
                    
                    <li><a href="/posts/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/">Python文件处理</a></li>
                    
                    <li><a href="/posts/python%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Python常用数据类型</a></li>
                    
                    <li><a href="/posts/python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">Python流程控制</a></li>
                    
                </ul>
                
            </div>
            
            
            
              
            </div>
            
            
        </div>
    </div>
    </section>
</div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
        <img src="https://ws3.sinaimg.cn/large/006tKfTcgy1ft8a0o1hlcj30ax0azjt4.jpg">
          
              <li>
                <a href="mailto:976199267@qq.com" title="Email me">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
                <a href="https://github.com/wtli/wtli.github.io" title="GitHub">
                  <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
        </ul>
        <p class="credits copyright text-muted">
        &copy;2017-2018
          
            
              wangtian
            
          
          
          
            &nbsp;&bull;&nbsp;
            <a href="https://www.eee.wiki/">wtlinux</a>
          
        </p>
        <p class="credits theme-by text-muted">
        <a href="http://www.wtlinux.com">wtlinux.com</a>&nbsp;&bull;&nbsp;<a href="https://www.eee.wiki">eee.wiki</a>&nbsp;&bull;&nbsp;<a href="https://www.bldz.com">www.bldz.com</a>
        </p>

        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.41</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/rootsongjc/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>


<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/bootstrap.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/photoswipe-ui-default.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/photoswipe.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/auto-render.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/main.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/prism.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/katex.min.js"></script>
<script> renderMathInElement(document.body); </script>







  </body>
</html>

